//@version=5
//This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/

// This combines LuxAlgo's "Breaker Blocks with Signals [LuxAlgo]" with makuchaku & eFe "Super OrderBlock / FVG / BoS Tools"
indicator('Sax Special: BreakerBlock,OrderBlock,FVG,SMT', overlay=true, max_boxes_count=500, max_lines_count=500)

plotOB = input.bool(defval=true, title='Plot OB', group='Order Blocks')
obBullColor = input.color(defval=color.new(color.green, 90), title='Bullish OB Color', inline='Set Custom Color', group='Order Blocks')
obBearColor = input.color(defval=color.new(color.red, 90), title='Bearish OB Color', inline='Set Custom Color', group='Order Blocks')
obBoxBorder = input.string(defval=line.style_solid, title='OB Box Border Style', options=[line.style_dashed, line.style_dotted, line.style_solid], group='Order Blocks', tooltip='To disable border, set Border Width below to 0')
obBorderTransparency = input.int(defval=80, title='OB Border Box Transparency', minval=0, maxval=100, group='Order Blocks')
obMaxBoxSet = input.int(defval=10, title='Maximum OB Box Displayed', minval=1, maxval=100, group='Order Blocks', tooltip='Minimum = 1, Maximum = 100')
filterMitOB = input.bool(defval=false, title='Custom Color Mitigated OB', group='Order Blocks')
mitOBColor = input.color(defval=color.new(color.gray, 90), title='Mitigated OB Color', group='Order Blocks', inline='Set Custom Color Mit OB', tooltip='Set Transparency to 0 to make mitigated OB disappear')

plotFVG = input.bool(defval=true, title='Plot FVG', group='Fair Value Gaps', inline='FVG sets')
plotStructureBreakingFVG = input.bool(defval=true, title='Plot Structure Breaking FVG', group='Fair Value Gaps', inline='FVG sets')
fvgBullColor = input.color(defval=color.new(color.black, 90), title='Bullish FVG Color', inline='Set Custom Color', group='Fair Value Gaps')
fvgBearColor = input.color(defval=color.new(color.black, 90), title='Bearish FVG Color', inline='Set Custom Color', group='Fair Value Gaps')
fvgStructBreakingColor = input.color(defval=color.new(color.blue, 90), title='Structure Breaking FVG Color', inline='Set Custom Color', group='Fair Value Gaps')
fvgBoxBorder = input.string(defval=line.style_solid, title='FVG Box Border Style', options=[line.style_dashed, line.style_dotted, line.style_solid], group='Fair Value Gaps', tooltip='To disable border, set Border Width below to 0')
fvgBorderTransparency = input.int(defval=80, title='FVG Border Box Transparency', minval=0, maxval=100, group='Fair Value Gaps')
fvgMaxBoxSet = input.int(defval=10, title='Maximum FVG Box Displayed', minval=1, maxval=100, group='Fair Value Gaps', tooltip='Minimum = 1, Maximum = 100')
filterMitFVG = input.bool(defval=false, title='Custom Color Mitigated FVG', group='Fair Value Gaps')
mitFVGColor = input.color(defval=color.new(color.gray, 90), title='Mitigated FVG Color', group='Fair Value Gaps', inline='Set Custom Color Mit FVG', tooltip='Set Transparency to 0 to make mitigated FVG disappear')

plotRJB = input.bool(defval=false, title='Plot RJB', group='Rejection Blocks', inline='RJB sets')
rjbBullColor = input.color(defval=color.new(color.green, 90), title='Bullish RJB Color', inline='Set Custom Color', group='Rejection Blocks')
rjbBearColor = input.color(defval=color.new(color.red, 90), title='Bearish RJB Color', inline='Set Custom Color', group='Rejection Blocks')
rjbBoxBorder = input.string(defval=line.style_solid, title='RJB Box Border Style', options=[line.style_dashed, line.style_dotted, line.style_solid], group='Rejection Blocks', tooltip='To disable border, set Border Width below to 0')
rjbBorderTransparency = input.int(defval=80, title='RJB Border Box Transparency', minval=0, maxval=100, group='Rejection Blocks')
rjbMaxBoxSet = input.int(defval=10, title='Maximum RJB Box Displayed', minval=1, maxval=100, group='Rejection Blocks', tooltip='Minimum = 1, Maximum = 100')
filterMitRJB = input.bool(defval=false, title='Custom Color Mitigated RJB', group='Rejection Blocks')
mitRJBColor = input.color(defval=color.new(color.gray, 90), title='Mitigated RJB Color', group='Rejection Blocks', inline='Set Custom Color Mit RJB', tooltip='Set to 100 to make mitigated RJB disappear')

plotPVT = input.bool(defval=true, title='Plot Pivots', group='Pivots')
pivotLookup  = input.int(defval=1, minval=1, maxval=5,title='Pivot Lookup', group='Pivots', tooltip='Minimum = 1, Maximum = 5')
pvtTopColor = input.color(defval=color.new(color.silver, 0), title='Pivot Top Color', group='Pivots', inline='PVT Color')
pvtBottomColor = input.color(defval=color.new(color.silver, 0), title='Pivot Bottom Color', group='Pivots', inline='PVT Color')

plotBOS = input.bool(defval=false, title='Plot BoS', group='Crossovers', inline='BOS sets')
useHighLowForBullishBoS = input.bool(defval=false, title='Use High/Low for Bullish BoS (for Bearish setup)', group='Crossovers')
useHighLowForBearishBoS = input.bool(defval=false, title='Use High/Low for Bearish BoS (for Bullish setup)', group='Crossovers')
bosBoxFlag  = input.bool(title='BoS Box Length Manually', defval=false, group='Crossovers', tooltip='If activated the BoS Boxes will not extend unitl crossed by price. Instead will extend by the amount of bars choosen in the "Set BoS Box Length Manually" option')
bosBoxLength  = input.int(title='BoS Box Length Manually', defval=3, minval=1, maxval=5, group='Crossovers', inline='BoS Boxes', tooltip='If "Set BoS Box Length Manually" is marked, choose by how many bars. Minimum = 1, Maximum = 5')
bosBullColor = input.color(defval=color.new(color.green, 90), title='Bullish BoS Color', inline='Set Custom Color', group='Crossovers')
bosBearColor = input.color(defval=color.new(color.red, 90), title='Bearish BoS Color', inline='Set Custom Color', group='Crossovers')
bosBoxBorder = input.string(defval=line.style_solid, title='BoS Box Border Style', options=[line.style_dashed, line.style_dotted, line.style_solid], group='Crossovers', tooltip='To disable border, set Border Width below to 0')
bosBorderTransparency = input.int(defval=80, title='BoS Border Box Transparency', minval=0, maxval=100, group='Crossovers')
bosMaxBoxSet = input.int(defval=10, title='Maximum BoS Box Displayed', minval=1, maxval=100, group='Crossovers', tooltip='Minimum = 1, Maximum = 100')

plotHVB = input.bool(defval=true, title='Plot HVB', group='High Volume Bar', tooltip='A candle where the average volume is higher than last few bars.')
hvbBullColor = input.color(defval=color.green, title='Bullish HVB Color', inline='Set Custom Color', group='High Volume Bar')
hvbBearColor = input.color(defval=color.red, title='Bearish HVB Color', inline='Set Custom Color', group='High Volume Bar')
hvbEMAPeriod = input.int(defval=12, minval=1, title='Volume EMA Period', group='High Volume Bar')
hvbMultiplier = input.float(defval=1.5, title='Volume Multiplier', minval=1, maxval=100, group='High Volume Bar')

plotPPDD = input.bool(defval=true, title="Plot PPDD OB's", group='Qualitative indicators', tooltip='Premium Premium Discount Discount (PPDD) is an OB formed after liquidity sweep. It will show up by default as a triangle (Bull ▲ / Bear ▼). Also PPDD1 (by deafult maked with a x-cross ⨯) which is a weak OB formed after liquidity sweep, that fails to completely engulf the high/low, but closes beyond the trapped candles open price.')
ppddBullColor = input.color(defval=color.new(color.green, 0), title="Bullish PPDD OB's Color", group='Qualitative indicators', inline='PPDD Color')
ppddBearColor = input.color(defval=color.new(color.red, 0), title="Bearish PPDD OB's Color", group='Qualitative indicators', inline='PPDD Color')

plotOBFVG = input.bool(defval=true, title='Plot Stacked OB+FVG', group='Qualitative indicators', tooltip='Marks the candle (default with a diamond ◆) when an OB & FVG are stacked, showing momentum')
obfvgBullColor = input.color(defval=color.new(color.green, 0), title='Bullish Stacked OB+FVG Color', group='Qualitative indicators', inline='OBFVG Color')
obfvgBearColor = input.color(defval=color.new(color.red, 0), title='Bearish Stacked OB+FVG Color', group='Qualitative indicators', inline='OBFVG Color')

plotLabelOB = input.bool(defval=true, title='Plot OB Label', inline='OB label', group='Label Options')
obLabelColor = input.color(defval=color.gray, title='Color', inline='OB label', group='Label Options')
obLabelSize = input.string(defval=size.tiny, title="Size", options=[size.huge, size.large, size.small, size.tiny, size.auto, size.normal], inline='OB label', group='Label Options')
plotLabelFVG = input.bool(defval=true, title='Plot FVG Label', inline='FVG label', group='Label Options')
fvgLabelColor = input.color(defval=color.gray, title='Color', inline='FVG label', group='Label Options')
fvgLabelSize = input.string(defval=size.tiny, title="Size", options=[size.huge, size.large, size.small, size.tiny, size.auto, size.normal], inline='FVG label', group='Label Options')
plotLabelRJB = input.bool(defval=true, title='Plot RJB Label', inline='RJB label', group='Label Options')
rjbLabelColor = input.color(defval=color.gray, title='Color', inline='RJB label', group='Label Options')
rjbLabelSize = input.string(defval=size.tiny, title="Size", options=[size.huge, size.large, size.small, size.tiny, size.auto, size.normal], inline='RJB label', group='Label Options')
plotLabelBOS = input.bool(defval=true, title='Plot BoS Label', inline='BOS label', group='Label Options')
bosLabelColor = input.color(defval=color.gray, title='Color', inline='BOS label', group='Label Options')
bosLabelSize = input.string(defval=size.tiny, title="Size", options=[size.huge, size.large, size.small, size.tiny, size.auto, size.normal], inline='BOS label', group='Label Options')

//Box Types
var int _ob  = 1
var int _fvg = 2
var int _rjb = 3
var int _bos = 4

//Box Labels
var string _obLabel  = "OB"
var string _fvgLabel = "FVG"
var string _rjbLabel = "RJB"
var string _bosLabel = "BoS"
var string _plus     = "+"
var string _minus    = "-"
var string _empty    = ""

//Box Arrays
var box[] _bearBoxesOB  = array.new_box()
var box[] _bullBoxesOB  = array.new_box()
var box[] _bearBoxesFVG = array.new_box()
var box[] _bullBoxesFVG = array.new_box()
var box[] _bearBoxesRJB = array.new_box()
var box[] _bullBoxesRJB = array.new_box()
var box[] _bearBoxesBOS = array.new_box()
var box[] _bullBoxesBOS = array.new_box()

//Functions
isUp(index) =>
    close[index] > open[index]

isDown(index) =>
    close[index] < open[index]

isObUp(index) =>
    isDown(index + 1) and isUp(index) and close[index] > high[index + 1]

isObDown(index) =>
    isUp(index + 1) and isDown(index) and close[index] < low[index + 1]

isFvgUp(index) =>
    (low[index] > high[index + 2])

isFvgDown(index) =>
    (high[index] < low[index + 2])

//Function to Calculte Box Length
_controlBox(_boxes, _high, _low, _type) =>
    if array.size(_boxes) > 0
        for i = array.size(_boxes) - 1 to 0 by 1
            _box = array.get(_boxes, i)
            _boxLow = box.get_bottom(_box)
            _boxHigh = box.get_top(_box)
            _boxRight = box.get_right(_box)
            if bosBoxFlag and _type == _bos
                if na or (bar_index + bosBoxLength - 1 == _boxRight and not((_high > _boxLow and _low < _boxLow) or (_high > _boxHigh and _low < _boxHigh)))
                    box.set_right(_box, bar_index + bosBoxLength - 1)
            else if (filterMitOB and _type == _ob) or (filterMitFVG and _type == _fvg) or (filterMitRJB and _type == _rjb)
                if na or (bar_index == _boxRight and not((_high > _boxLow and _low < _boxLow) or (_high > _boxHigh and _low < _boxHigh)))
                    box.set_right(_box, bar_index + 1)
                else
                    if _type == _ob
                        box.set_bgcolor(_box, mitOBColor)
                        box.set_border_color(_box, mitOBColor)
                    else if _type == _fvg
                        box.set_bgcolor(_box, mitFVGColor)
                        box.set_border_color(_box, mitFVGColor)
                    else if _type == _rjb
                        box.set_bgcolor(_box, mitRJBColor)
                        box.set_border_color(_box, mitRJBColor)
            else
                if na or (bar_index == _boxRight and not((_high > _boxLow and _low < _boxLow) or (_high > _boxHigh and _low < _boxHigh)))
                    box.set_right(_box, bar_index + 1)

//////////////////// Pivots //////////////////// 
hih = ta.pivothigh(high, pivotLookup, pivotLookup)
lol = ta.pivotlow(low , pivotLookup, pivotLookup)
top = ta.valuewhen(hih, high[pivotLookup], 0)
bottom = ta.valuewhen(lol, low [pivotLookup], 0)
plot(top, offset=-pivotLookup, linewidth=1, color=(top != top[1] ? na : (plotPVT ? pvtTopColor : na)), title="Pivot Top")
plot(bottom, offset=-pivotLookup, linewidth=1, color=(bottom != bottom[1] ? na : (plotPVT ? pvtBottomColor : na)), title="Pivot Bottom")

//////////////////// Order Block //////////////////
//Bullish OB Box Plotting
if isObUp(1) and plotOB
    _bullboxOB = box.new(left=bar_index - 2, top=high[2], right=bar_index, bottom=math.min(low[2], low[1]), border_color=color.new(obBullColor, obBorderTransparency), border_style=obBoxBorder, border_width=1, bgcolor=obBullColor, 
     text=plotLabelOB ? _obLabel  + _plus : _empty, text_halign=text.align_right, text_valign=text.align_bottom, text_size=obLabelSize, text_color=obLabelColor)
    if array.size(_bullBoxesOB) > obMaxBoxSet
        box.delete(array.shift(_bullBoxesOB))
    array.push(_bullBoxesOB, _bullboxOB)

//Bearish OB Box Plotting
if isObDown(1) and plotOB
    _bearboxOB = box.new(left=bar_index - 2, top=math.max(high[2], high[1]), right=bar_index, bottom=low[2], border_color=color.new(obBearColor, obBorderTransparency), border_style=obBoxBorder, border_width=1, bgcolor=obBearColor, 
     text=plotLabelOB ? _obLabel  + _minus : _empty, text_halign=text.align_right, text_valign=text.align_bottom, text_size=obLabelSize, text_color=obLabelColor)
    if array.size(_bearBoxesOB) > obMaxBoxSet
        box.delete(array.shift(_bearBoxesOB))
    array.push(_bearBoxesOB, _bearboxOB)
    
if plotOB
    _controlBox(_bearBoxesOB, high, low, _ob)
    _controlBox(_bullBoxesOB, high, low, _ob)

//////////////////// Fair Value Gap //////////////////
//Bullish FVG Box Plotting
if isFvgUp(0)
    box _bullboxFVG = na
    if plotStructureBreakingFVG and (close[1] > top) and (low[1] < top) and (high[2] < top) and (low > top)
        _bullboxFVG := box.new(left=bar_index-2, top=low[0], right=bar_index, bottom=high[2], bgcolor=fvgStructBreakingColor, border_color=color.new(fvgStructBreakingColor, fvgBorderTransparency), border_style=fvgBoxBorder, border_width=1,
         text=plotLabelFVG ? _fvgLabel  + _plus : _empty, text_halign=text.align_right, text_valign=text.align_bottom, text_size=fvgLabelSize, text_color=fvgLabelColor)        
    else if plotFVG   
        _bullboxFVG := box.new(left=bar_index-2, top=low[0], right=bar_index, bottom=high[2], bgcolor=fvgBullColor, border_color=color.new(fvgBullColor, fvgBorderTransparency), border_style=fvgBoxBorder, border_width=1,
         text=plotLabelFVG ? _fvgLabel  + _plus : _empty, text_halign=text.align_right, text_valign=text.align_bottom, text_size=fvgLabelSize, text_color=fvgLabelColor)    
    if array.size(_bullBoxesFVG) > fvgMaxBoxSet
        box.delete(array.shift(_bullBoxesFVG))
    array.push(_bullBoxesFVG, _bullboxFVG)

//Bearish FVG Box Plotting    
if isFvgDown(0)
    box _bearboxFVG = na
    if plotStructureBreakingFVG and (close[1] < bottom) and (high[1] > bottom) and (low[2] > bottom) and (high < bottom)
        _bearboxFVG := box.new(left=bar_index-2, top=low[2], right=bar_index, bottom=high[0], bgcolor=fvgStructBreakingColor, border_color=color.new(fvgStructBreakingColor, fvgBorderTransparency), border_style=fvgBoxBorder, border_width=1,
         text=plotLabelFVG ? _fvgLabel  + _minus : _empty, text_halign=text.align_right, text_valign=text.align_bottom, text_size=fvgLabelSize, text_color=fvgLabelColor)    
    else if plotFVG
        _bearboxFVG := box.new(left=bar_index-2, top=low[2], right=bar_index, bottom=high[0], bgcolor=fvgBearColor, border_color=color.new(fvgBearColor, fvgBorderTransparency), border_style=fvgBoxBorder, border_width=1,
         text=plotLabelFVG ? _fvgLabel  + _minus : _empty, text_halign=text.align_right, text_valign=text.align_bottom, text_size=fvgLabelSize, text_color=fvgLabelColor)    
    if array.size(_bearBoxesFVG) > fvgMaxBoxSet
        box.delete(array.shift(_bearBoxesFVG))
    array.push(_bearBoxesFVG, _bearboxFVG)
    
if plotFVG or plotStructureBreakingFVG
    _controlBox(_bearBoxesFVG, high, low, _fvg)
    _controlBox(_bullBoxesFVG, high, low, _fvg)

//////////////////// Rejection Block //////////////////
if plotRJB
    isDownRjbObCondition = isObDown(1)
    isDownRjb1 = isDownRjbObCondition and  (high[1] < (close[2] + 0.2*(high[2]-close[2]))) // RJB is on trapped's wick and <50% of the wick was covered by signal
    isDownRjb2 = isDownRjbObCondition and (high[1] > high[2]) // RJB is on signal's wick
    if isDownRjb1 and plotRJB
        _bearboxRJB = box.new(left=bar_index-2, top=high[2], right=bar_index, bottom=close[2], bgcolor=rjbBearColor, border_color=color.new(rjbBearColor, rjbBorderTransparency), border_style=rjbBoxBorder, border_width=1,
         text=plotLabelRJB ? _rjbLabel  + _minus : _empty, text_halign=text.align_right, text_valign=text.align_bottom, text_size=rjbLabelSize, text_color=rjbLabelColor)
        if array.size(_bearBoxesRJB) > rjbMaxBoxSet
            box.delete(array.shift(_bearBoxesRJB))
        array.push(_bearBoxesRJB, _bearboxRJB)
        
    if isDownRjb2 and plotRJB
        _bearboxRJB = box.new(left=bar_index-1, top=high[1], right=bar_index, bottom=open[1], bgcolor=rjbBearColor, border_color=color.new(rjbBearColor, rjbBorderTransparency), border_style=rjbBoxBorder, border_width=1,
         text=plotLabelRJB ? _rjbLabel  + _minus : _empty, text_halign=text.align_right, text_valign=text.align_bottom, text_size=rjbLabelSize, text_color=rjbLabelColor)
        if array.size(_bearBoxesRJB) > rjbMaxBoxSet
            box.delete(array.shift(_bearBoxesRJB))
        array.push(_bearBoxesRJB, _bearboxRJB)

//Bullish RJB Box Plotting
if plotRJB
    isUpRjbObCondition = isObUp(1)
    isUpRjb1 = isUpRjbObCondition and (low[1] > (close[2] - 0.2*(close[2]-low[2]))) // RJB is on trapped's wick and <50% of the wick was covered by signal
    isUpRjb2 = isUpRjbObCondition and (low[1] < low[2]) // RJB is on signal's wick
    if isUpRjb1 and plotRJB
        _bullboxRJB = box.new(left=bar_index-2, top=close[2], right=bar_index, bottom=low[2], bgcolor=rjbBullColor, border_color=color.new(rjbBullColor, rjbBorderTransparency), border_style=rjbBoxBorder, border_width=1,
         text=plotLabelRJB ? _rjbLabel  + _plus : _empty, text_halign=text.align_right, text_valign=text.align_bottom, text_size=rjbLabelSize, text_color=rjbLabelColor)
        if array.size(_bullBoxesRJB) > rjbMaxBoxSet
            box.delete(array.shift(_bullBoxesRJB))
        array.push(_bullBoxesRJB, _bullboxRJB)
    
    if isUpRjb2 and plotRJB
        _bullboxRJB = box.new(left=bar_index-1, top=open[1], right=bar_index, bottom=low[1], bgcolor=rjbBullColor, border_color=color.new(rjbBullColor, rjbBorderTransparency), border_style=rjbBoxBorder, border_width=1, 
         text=plotLabelRJB ? _rjbLabel  + _plus : _empty, text_halign=text.align_right, text_valign=text.align_bottom, text_size=rjbLabelSize, text_color=rjbLabelColor)
        if array.size(_bullBoxesRJB) > rjbMaxBoxSet
            box.delete(array.shift(_bullBoxesRJB))
        array.push(_bullBoxesRJB, _bullboxRJB)

if plotRJB
    _controlBox(_bearBoxesRJB, high, low, _rjb)
    _controlBox(_bullBoxesRJB, high, low, _rjb)

//////////////////// Crossovers a.k.a. Break of Structure ////////////////////
//Bullish BOS Box Plotting
if plotBOS
    if ta.crossover(useHighLowForBullishBoS ? high : close, top)
        _bullboxBOS = box.new(left=bar_index, top=top, right=bosBoxFlag ? bar_index+bosBoxLength : bar_index+1, bottom=bottom, bgcolor=bosBullColor, border_color=color.new(bosBullColor, bosBorderTransparency), border_style=bosBoxBorder, border_width=1, 
         text=plotLabelBOS ? _bosLabel + _plus : _empty, text_halign=text.align_right, text_valign=text.align_bottom, text_size=bosLabelSize, text_color=bosLabelColor)
        if array.size(_bullBoxesBOS) > bosMaxBoxSet
            box.delete(array.shift(_bullBoxesBOS))
        array.push(_bullBoxesBOS, _bullboxBOS)

//Bearish BOS Box Plotting        
if plotBOS 
    if ta.crossunder(useHighLowForBearishBoS ? low : close, bottom)
        _bearboxBOS = box.new(left=bar_index, top=top, right=bosBoxFlag ? bar_index+bosBoxLength : bar_index+1, bottom=bottom, bgcolor=bosBearColor, border_color=color.new(bosBearColor, bosBorderTransparency), border_style=bosBoxBorder, border_width=1, 
         text=plotLabelBOS ? _bosLabel  + _minus : _empty, text_halign=text.align_right, text_valign=text.align_bottom, text_size=bosLabelSize, text_color=bosLabelColor)
        if array.size(_bearBoxesBOS) > bosMaxBoxSet
            box.delete(array.shift(_bearBoxesBOS))
        array.push(_bearBoxesBOS, _bearboxBOS)

if plotBOS
    _controlBox(_bearBoxesBOS, high, low, _bos)
    _controlBox(_bullBoxesBOS, high, low, _bos)

//////////////////// Premium Premium & Discount Discount //////////////////
premiumPremium = plotPPDD and isObDown(0) and ((math.max(high, high[1]) > top and close < top) or (math.max(high, high[1]) > top[1] and close < top[1]))
discountDiscount = plotPPDD and isObUp(0) and ((math.min(low, low[1]) < bottom and close > bottom) or (math.min(low, low[1]) < bottom[1] and close > bottom[1]))
plotshape(premiumPremium, "Bearish PPDD OB", style=shape.triangledown , location=location.abovebar, color=ppddBearColor, size=size.tiny)
plotshape(discountDiscount, "Bullish PPDD OB", style=shape.triangleup , location=location.belowbar, color=ppddBullColor, size=size.tiny)

premiumPremium1 = plotPPDD and (isUp(1) and isDown(0) and close[0] < open[1]) and ((math.max(high, high[1]) > top and close < top) or (math.max(high, high[1]) > top[1] and close < top[1])) and not premiumPremium
discountDiscount1 = plotPPDD and (isDown(1) and isUp(0) and close[0] > open[1]) and ((math.min(low, low[1]) < bottom and close > bottom) or (math.min(low, low[1]) < bottom[1] and close > bottom[1])) and not discountDiscount
plotshape(premiumPremium1, "Bearish PPDD Weak OB", style=shape.xcross, location=location.abovebar, color=ppddBearColor, size=size.tiny)
plotshape(discountDiscount1, "Bullish PPDD Weak OB", style=shape.xcross, location=location.belowbar, color=ppddBullColor, size=size.tiny)

////////////////// High Volume Bars //////////////////
volEma = ta.ema(volume, hvbEMAPeriod)
isHighVolume = volume > (hvbMultiplier * volEma)
barcolor(plotHVB and isUp(0) and isHighVolume ? hvbBullColor : na, title="Bullish HVB")
barcolor(plotHVB and isDown(0) and isHighVolume ? hvbBearColor : na, title="Bearish HVB")

///////////////// Stacked OB + FVG //////////////////
plotshape(plotOBFVG and isFvgDown(0) and isObDown(1), "Bearish OB+FVG Stack", style=shape.diamond, location=location.abovebar, color=obfvgBearColor, size=size.tiny)
plotshape(plotOBFVG and isFvgUp(0) and isObUp(1), "Bullish OB+FVG Stack", style=shape.diamond, location=location.belowbar, color=obfvgBullColor, size=size.tiny)

///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
////////////////// LUX ALGO's BREAKER BLOCK     ///////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

// This work is licensed under a Attribution-NonCommercial-ShareAlike 4.0 International (CC Dy-NC-SA 4.0) https://creativecommons.org/licenses/Dy-nc-sa/4.0/
// © LuxAlgo
// From Breaker Blocks with Signals [LuxAlgo]
//@version=5


//------------------------------------------------------------------------------
//Settings
//-----------------------------------------------------------------------------{
shZZ                  = false 
len                   = input.int   (    5     , title='      Length'              , inline='MS' , group='Market Structure' 
                      ,                                         minval=1, maxval=10                                                                      )
//Breaker block
breakerCandleOnlyBody = input.bool  (  false   , title='Use only candle body'                    , group='Breaker Block'                                 )
breakerCandle_2Last   = input.bool  (  false   , title='Use 2 candles instead of 1'              , group='Breaker Block', tooltip='In the same direction')
tillFirstBreak        = input.bool  (  true   , title='Stop at first break of center line'      , group='Breaker Block'                                 )

//PD array
onlyWhenInPDarray     = input.bool  (  false   , title='Only when E is in Premium/Discount Array', group='PD array'                                      )
showPDarray           = input.bool  (  false   , title='show Premium/Discount Zone'              , group='PD array'                                      )
showBreaks            = input.bool  (  false   , title='Highlight Swing Breaks'                  , group='PD array'                                      )
showSPD               = input.bool  (  true    , title='Show Swings/PD Arrays'                   , group='PD array'                                      )
PDtxtCss              = input.color (  color.silver, 'Text Color'      , group='PD array'                                      )
PDSCss                = input.color (  color.silver, 'Swing Line Color', group='PD array'                                      )

//Take profit
iTP                   = input.bool  (  false   , title='Enable TP'                 , inline='RR' , group='TP'                                            )
tpCss                 = input.color ( #2157f3, title=''                  , inline='RR', group='TP'                                            )
R1a                   = input.float (    1     , title='R:R 1', minval= 1, maxval=1, inline='RR1', group='TP'                                            )
R2a                   = input.float (    2     , title= ':'   , minval=.2, step= .1, inline='RR1', group='TP'                                            )
R1b                   = input.float (    1     , title='R:R 2', minval= 1, maxval=1, inline='RR2', group='TP'                                            )
R2b                   = input.float (    3     , title= ':'   , minval=.2, step= .1, inline='RR2', group='TP'                                            )
R1c                   = input.float (    1     , title='R:R 3', minval= 1, maxval=1, inline='RR3', group='TP'                                            )
R2c                   = input.float (    4     , title= ':'   , minval=.2, step= .1, inline='RR3', group='TP'                                            )
 
//Colors
cBBplusA              = input.color (color.rgb(12, 181, 26, 93)
                                               , title='      '                    , inline='bl' , group='Breaker Blocks    +BB                   Last Swings'  )
cBBplusB              = input.color (color.rgb(12, 181, 26, 85)
                                               , title=''                          , inline='bl' , group='Breaker Blocks    +BB                   Last Swings'  )
cSwingBl              = input.color (color.rgb(255, 82, 82, 85)
                                               , title='        '                  , inline='bl' , group='Breaker Blocks    +BB                   Last Swings'  )
cBB_minA              = input.color (color.rgb(255, 17, 0, 95)
                                               , title='      '                    , inline='br' , group='Breaker Blocks    -BB                   Last Swings'  )
cBB_minB              = input.color (color.rgb(255, 17, 0, 85)
                                               , title=''                          , inline='br' , group='Breaker Blocks    -BB                   Last Swings'  )
cSwingBr              = input.color (color.rgb(0, 137, 123, 85)
                                               , title='        '                  , inline='br' , group='Breaker Blocks    -BB                   Last Swings'  )

_arrowup = '▲'
_arrowdn = '▼'
_c = '●'
_x = '❌'

//-----------------------------------------------------------------------------}
//General Calculations
//-----------------------------------------------------------------------------{
per        = last_bar_index - bar_index <= 2000 
mx         = math.max(close , open     )
mn         = math.min(close , open )
atr        = ta.atr  (10    )
n          = bar_index
hi         = high  
lo         = low   
mCxSize    = 50

//-----------------------------------------------------------------------------}
//User Defined Types
//-----------------------------------------------------------------------------{
type ZZ 
    int   [] d
    int   [] x 
    float [] y 
    line  [] l
    bool  [] b

type mss 
    int     dir
    line [] l_mssBl
    line [] l_mssBr
    line [] l_bosBl
    line [] l_bosBr
    label[] lbMssBl
    label[] lbMssBr
    label[] lbBosBl
    label[] lbBosBr

type block
    int   dir
    bool  Broken
    bool  Mitigated
    box   BB_boxA
    box   BB_boxB
    line  BB_line
    box   FVG_box
    line  line_1
    line  line_2
    bool  Broken_1
    bool  Broken_2
    box   PDa_boxA
    box   PDa_boxB
    box   PDa_box1
    line  PDaLine1
    label PDaLab_1
    box   PDa_box2
    line  PDaLine2    
    label PDaLab_2
    bool  PDbroken1
    bool  PDbroken2
    line  TP1_line
    line  TP2_line
    line  TP3_line
    bool  TP1_hit
    bool  TP2_hit
    bool  TP3_hit
    bool  scalp
    label HL
    label[] aLabels

//-----------------------------------------------------------------------------}
//Variables
//-----------------------------------------------------------------------------{
BBplus = 0, signUP = 1, cnclUP = 2, LL1break = 3, LL2break = 4, SW1breakUP = 5
 ,      SW2breakUP = 6,  tpUP1 = 7,    tpUP2 = 8,    tpUP3 = 9,   BB_endBl =10
BB_min =11, signDN =12, cnclDN =13, HH1break =14, HH2break =15, SW1breakDN =16
 ,      SW2breakDN =17,  tpDN1 =18,    tpDN2 =19,    tpDN3 =20,   BB_endBr =21

signals = 
 array.from(
   false // BBplus
 , false // signUP
 , false // cnclUP
 , false // LL1break
 , false // LL2break
 , false // SW1breakUP
 , false // SW2breakUP
 , false // tpUP1
 , false // tpUP2
 , false // tpUP3
 , false // BB_endBl
 , false // BB_min
 , false // signDN
 , false // cnclDN
 , false // HH1break
 , false // HH2break
 , false // SW1breakDN
 , false // SW2breakDN
 , false // tpDN1
 , false // tpDN2
 , false // tpDN3
 , false // BB_endBr
 )

var block   [] aBlockBl   = array.new<   block  >(          )
var block   [] aBlockBr   = array.new<   block  >(          )

var  ZZ         aZZ       = 
 ZZ.new(
 array.new < int    >(mCxSize,  0), 
 array.new < int    >(mCxSize,  0), 
 array.new < float  >(mCxSize, na),
 array.new < line   >(mCxSize, na),
 array.new < bool   >(mCxSize, na))

var mss MSS = mss.new(
 0
 , array.new < line  >()
 , array.new < line  >() 
 , array.new < line  >()
 , array.new < line  >()
 , array.new < label >() 
 , array.new < label >()
 , array.new < label >()
 , array.new < label >()
 )

var block BB = block.new(
   BB_boxA   = box.new  (na, na, na, na, border_color=color(na))
 , BB_boxB   = box.new  (na, na, na, na, border_color=color(na)
  , text_size=size.small
  , text_halign=text.align_right
  , text_font_family=font.family_monospace
  )
 , BB_line   = line.new (na, na, na, na
  , style=line.style_dashed
  , color=color.silver
  )
 , PDa_box1  = box.new  (na, na, na, na, border_color=color(na))
 , PDaLine1  = line.new (na, na, na, na, color=PDSCss)
 , PDaLab_1  = label.new(na, na, color=color(na))
 , PDa_box2  = box.new  (na, na, na, na, border_color=color(na))
 , PDaLine2  = line.new (na, na, na, na, color=PDSCss)
 , PDaLab_2  = label.new(na, na, color=color(na))
 , line_1    = line.new (na, na, na, na, color=PDSCss)
 , line_2    = line.new (na, na, na, na, color=PDSCss)
 , TP1_line  = line.new (na, na, na, na, color=tpCss)
 , TP2_line  = line.new (na, na, na, na, color=tpCss)
 , TP3_line  = line.new (na, na, na, na, color=tpCss)
 , HL        = label.new(na, na, color=color(na)
  , textcolor=PDtxtCss
  , yloc=yloc.price
  )
 , aLabels   = array.new<label>(1, label(na))
 )

//-----------------------------------------------------------------------------}
//Functions/methods
//-----------------------------------------------------------------------------{
method in_out(ZZ aZZ, int d, int x1, float y1, int x2, float y2, color col, bool b) =>
    aZZ.d.unshift(d), aZZ.x.unshift(x2), aZZ.y.unshift(y2), aZZ.b.unshift(b), aZZ.d.pop(), aZZ.x.pop(), aZZ.y.pop(), aZZ.b.pop()
    if shZZ
        aZZ.l.unshift(line.new(x1, y1, x2, y2, color= col)), aZZ.l.pop().delete()

method io_box(box[] aB, box b) => aB.unshift(b), aB.pop().delete()

method setLine(line ln, int x1, float y1, int x2, float y2) => ln.set_xy1(x1, y1), ln.set_xy2(x2, y2)

method notransp(color css) => color.rgb(color.r(css), color.g(css), color.b(css))

createLab(string s, float y, color c, string t, string sz = size.small) =>      
    label.new(n
     , y
     , style=s == 'c' ? label.style_label_center    
      : s == 'u' ? label.style_label_up 
      : label.style_label_down
     , textcolor=c
     , color=color(na)    
     , size=sz
     , text=t
     )

draw(left, col) =>
    
    max_bars_back(time, 1000)
    var int dir= na, var int x1= na, var float y1= na, var int x2= na, var float y2= na
    
    sz       = aZZ.d.size( )
    x2      := bar_index -1
    ph       = ta.pivothigh(hi, left, 1)
    pl       = ta.pivotlow (lo, left, 1)
    if ph   
        dir := aZZ.d.get (0) 
        x1  := aZZ.x.get (0) 
        y1  := aZZ.y.get (0) 
        y2  :=      nz(hi[1])
        
        if dir <  1  // if previous point was a pl, add, and change direction ( 1)
            aZZ.in_out( 1, x1, y1, x2, y2, col, true)
        else
            if dir ==  1 and ph > y1 
                aZZ.x.set(0, x2), aZZ.y.set(0, y2)   
                if shZZ
                    aZZ.l.get(0).set_xy2(x2, y2)        

    if pl
        dir := aZZ.d.get (0) 
        x1  := aZZ.x.get (0) 
        y1  := aZZ.y.get (0) 
        y2  :=      nz(lo[1])
        
        if dir > -1  // if previous point was a ph, add, and change direction (-1)
            aZZ.in_out(-1, x1, y1, x2, y2, col, true)
        else
            if dir == -1 and pl < y1 
                aZZ.x.set(0, x2), aZZ.y.set(0, y2)       
                if shZZ
                    aZZ.l.get(0).set_xy2(x2, y2)   
    
    iH = aZZ.d.get(2) ==  1 ? 2 : 1
    iL = aZZ.d.get(2) == -1 ? 2 : 1
    
    switch
        // MSS Bullish
        close > aZZ.y.get(iH) and aZZ.d.get(iH) ==  1 and MSS.dir <  1 and per =>
            
            Ex   = aZZ.x.get(iH -1), Ey = aZZ.y.get(iH -1) 
            Dx   = aZZ.x.get(iH   ), Dy = aZZ.y.get(iH   ), DyMx = mx[n - Dx]
            Cx   = aZZ.x.get(iH +1), Cy = aZZ.y.get(iH +1) 
            Bx   = aZZ.x.get(iH +2), By = aZZ.y.get(iH +2), ByMx = mx[n - Bx] 
            Ax   = aZZ.x.get(iH +3), Ay = aZZ.y.get(iH +3), AyMn = mn[n - Ax]
            _y   = math.max(ByMx, DyMx)
            mid  = AyMn + ((_y - AyMn) / 2) // 50% fib A- min(B, D)
            isOK = onlyWhenInPDarray ? Ay < Cy and Ay < Ey and Ey < mid : true
            
            float green1prT = na
            float green1prB = na
            float    avg    = na

            if Ey < Cy and Cx != Dx and isOK 
                // latest HH to 1 HH further -> search first green bar
                for i = n - Dx to n - Cx
                    if close[i] > open[i]
                        // reset previous swing box's
                        BB.PDa_box1.set_lefttop(na, na), BB.PDaLine1.set_xy1(na, na), BB.PDaLab_1.set_xy(na, na)
                        BB.PDa_box2.set_lefttop(na, na), BB.PDaLine2.set_xy1(na, na), BB.PDaLab_2.set_xy(na, na)
                        
                        green1idx   = n - i
                        green1prT  := breakerCandleOnlyBody ? mx[i] : high[i]
                        green1prB  := breakerCandleOnlyBody ? mn[i] : low [i]
                        if breakerCandle_2Last 
                            if close[i +1] > open[i +1]
                                green2prT  = breakerCandleOnlyBody ? mx[i +1] : high[i +1]
                                green2prB  = breakerCandleOnlyBody ? mn[i +1] : low [i +1]
                                if green2prT > green1prT or green2prB < green1prB
                                    green1idx -= 1
                                green1prT := math.max(green1prT, green2prT)
                                green1prB := math.min(green1prB, green2prB)
                        
                        // Breaker Block + 
                        avg := math.avg(green1prB, green1prT)
                        while BB.aLabels.size() > 0
                            BB.aLabels.pop().delete()
                        BB.PDa_boxA.delete(), BB.PDa_boxB.delete(), BB.dir :=  1
                        BB.BB_boxA.set_left   (green1idx)
                        BB.BB_boxA.set_top    (green1prT)
                        BB.BB_boxA.set_right  (    n    )
                        BB.BB_boxA.set_bottom (green1prB)
                        BB.BB_boxA.set_bgcolor(cBBplusA )

                        BB.BB_boxB.set_left   (    n    )
                        BB.BB_boxB.set_top    (green1prT)
                        BB.BB_boxB.set_right  (    n + 8)
                        BB.BB_boxB.set_bottom (green1prB)
                        BB.BB_boxB.set_bgcolor(cBBplusB )
                        BB.BB_boxB.set_text('+BB')
                        BB.BB_boxB.set_text_color(cBBplusB.notransp())
                        BB.BB_boxB.set_text_valign(text.align_bottom)
                       
                        BB.BB_line.set_xy1(n, avg), BB.BB_line.set_xy2(n , avg)

                        if showSPD
                            BB.line_1.set_xy1(Cx, Cy), BB.line_1.set_xy2(n , Cy), BB.Broken_1 := false
                            BB.line_2.set_xy1(Ex, Ey), BB.line_2.set_xy2(n , Ey), BB.Broken_2 := false
                            BB.HL.set_xy(Ex, Ey), BB.HL.set_style(label.style_label_up), BB.HL.set_text('LL')
                        
                        BB.TP1_hit    := false     
                        BB.TP2_hit    := false                              
                        BB.TP3_hit    := false  
                        BB.Broken     := false
                        BB.Mitigated  := false
                        BB.scalp      := false
                        BB.PDbroken1  := false
                        BB.PDbroken2  := false

                        if onlyWhenInPDarray and showPDarray
                            BB.PDa_boxA := box.new(Ax, mid, Ex +1, AyMn, bgcolor=color.rgb(132, 248, 171, 90), border_color=color(na)
                             , text = 'Discount PD Array', text_size = size.small, text_color = color.rgb(132, 248, 171, 25)
                             , text_halign = text.align_right, text_valign = text.align_center, text_font_family = font.family_monospace) // , text_wrap= text.wrap_auto
                            BB.PDa_boxB := box.new(Ax,  _y, Ex +1,  mid, bgcolor=color.rgb(248, 153, 132, 90), border_color=color(na))
                        
                        // Previous swings
                        cnt = 0, hh1 = high
                        for c = 0 to sz -2
                            getX = aZZ.x.get(c)
                            getY = aZZ.y.get(c)
                            if getY > hh1 and aZZ.d.get(c) ==  1 and showSPD
                                getY2 = (high[n - getX] - mn[n - getX]) / 4
                                switch cnt
                                    0 =>
                                        BB.PDa_box1.set_lefttop    (getX,        getY )
                                        BB.PDaLine1.set_xy1        (getX,        getY )
                                        BB.PDa_box1.set_rightbottom(n   , getY - getY2)
                                        BB.PDaLine1.set_xy2        (n   , getY        )
                                        BB.PDa_box1.set_bgcolor    (       cSwingBl   )
                                        BB.PDaLab_1.set_xy         (       getX, getY )
                                        BB.PDaLab_1.set_size       (       size.small )
                                        BB.PDaLab_1.set_textcolor  (    PDtxtCss )
                                        BB.PDaLab_1.set_text       ('Premium PD Array')
                                        BB.PDaLab_1.set_style(label.style_label_lower_left)
                                        cnt := 1                                        
                                        hh1 := getY
                                    1 =>
                                        if getY - getY2 > hh1
                                            BB.PDa_box2.set_lefttop    (getX,        getY )
                                            BB.PDaLine2.set_xy1        (getX,        getY )
                                            BB.PDa_box2.set_rightbottom(n   , getY - getY2)
                                            BB.PDaLine2.set_xy2        (n   , getY        )
                                            BB.PDa_box2.set_bgcolor    (       cSwingBl   )
                                            BB.PDaLab_2.set_xy         (       getX, getY )
                                            BB.PDaLab_2.set_size       (       size.small )
                                            BB.PDaLab_2.set_textcolor  (    PDtxtCss )
                                            BB.PDaLab_2.set_text       ('Premium PD Array')
                                            BB.PDaLab_2.set_style(label.style_label_lower_left)                                    
                                            cnt := 2
                            if cnt == 2
                                break                         

                        I  = green1prT - green1prB
                        E1 = green1prT + (I * R2a / R1a)
                        E2 = green1prT + (I * R2b / R1b)
                        E3 = green1prT + (I * R2c / R1c)

                        if iTP
                            if not BB.TP1_hit
                                BB.TP1_line.set_xy1(n, E1)  
                                BB.TP1_line.set_xy2(n + 20, E1)  
                            if not BB.TP2_hit
                                BB.TP2_line.set_xy1(n, E2)  
                                BB.TP2_line.set_xy2(n + 20, E2) 
                            if not BB.TP3_hit
                                BB.TP3_line.set_xy1(n, E3)  
                                BB.TP3_line.set_xy2(n + 20, E3) 

                        signals.set(BBplus, true)                        
                        alert('+BB', alert.freq_once_per_bar_close)
                        BB.aLabels.unshift(createLab('u', low, cBBplusB.notransp(), _arrowup, size.large))

                        break

            MSS.dir :=  1
            
        // MSS Bearish
        close < aZZ.y.get(iL) and aZZ.d.get(iL) == -1 and MSS.dir > -1 and per =>
            Ex   = aZZ.x.get(iL -1), Ey = aZZ.y.get(iL -1) 
            Dx   = aZZ.x.get(iL   ), Dy = aZZ.y.get(iL   ), DyMn = mn[n - Dx]
            Cx   = aZZ.x.get(iL +1), Cy = aZZ.y.get(iL +1) 
            Bx   = aZZ.x.get(iL +2), By = aZZ.y.get(iL +2), ByMn = mn[n - Bx] 
            Ax   = aZZ.x.get(iL +3), Ay = aZZ.y.get(iL +3), AyMx = mx[n - Ax]
            _y   = math.min(ByMn, DyMn)
            //_x   = _y == ByMn ? Bx : Dx
            mid  = AyMx - ((AyMx - _y) / 2) // 50% fib A- min(B, D)
            isOK = onlyWhenInPDarray ? Ay > Cy and Ay > Ey and Ey > mid : true
            //
            float red_1_prT = na
            float red_1_prB = na
            float    avg    = na
            if Ey > Cy and Cx != Dx and isOK 
                // latest LL to LL further -> search first red bar
                for i = n - Dx to n - Cx
                    if close[i] < open[i]
                        // reset previous swing box's
                        BB.PDa_box1.set_lefttop(na, na), BB.PDaLine1.set_xy1(na, na), BB.PDaLab_1.set_xy(na, na)
                        BB.PDa_box2.set_lefttop(na, na), BB.PDaLine2.set_xy1(na, na), BB.PDaLab_2.set_xy(na, na)

                        red_1_idx  = n - i
                        red_1_prT  := breakerCandleOnlyBody ? mx[i] : high[i]
                        red_1_prB  := breakerCandleOnlyBody ? mn[i] : low [i]
                        if breakerCandle_2Last 
                            if close[i +1] < open[i +1]
                                red_2_prT  = breakerCandleOnlyBody ? mx[i +1] : high[i +1]
                                red_2_prB  = breakerCandleOnlyBody ? mn[i +1] : low [i +1]
                                if red_2_prT > red_1_prT or red_2_prB < red_1_prB
                                    red_1_idx -= 1
                                red_1_prT := math.max(red_1_prT, red_2_prT)
                                red_1_prB := math.min(red_1_prB, red_2_prB)
                        
                        // Breaker Block -
                        avg := math.avg(red_1_prB, red_1_prT)
                        while BB.aLabels.size() > 0
                            BB.aLabels.pop().delete()
                        BB.PDa_boxA.delete(), BB.PDa_boxB.delete(), BB.dir := -1
                        BB.BB_boxA.set_left   (red_1_idx)
                        BB.BB_boxA.set_top    (red_1_prT)
                        BB.BB_boxA.set_right  (    n    )
                        BB.BB_boxA.set_bottom (red_1_prB)
                        BB.BB_boxA.set_bgcolor(cBB_minA )

                        BB.BB_boxB.set_left   (n)
                        BB.BB_boxB.set_top    (red_1_prT)
                        BB.BB_boxB.set_right  (    n + 8)
                        BB.BB_boxB.set_bottom (red_1_prB)
                        BB.BB_boxB.set_bgcolor(cBB_minB )
                        BB.BB_boxB.set_text('-BB')
                        BB.BB_boxB.set_text_color(cBB_minB.notransp())
                        BB.BB_boxB.set_text_valign(text.align_top)

                        BB.BB_line.set_xy1(n, avg), BB.BB_line.set_xy2(n , avg)

                        if showSPD
                            BB.line_1.set_xy1(Cx, Cy), BB.line_1.set_xy2(n , Cy), BB.Broken_1 := false
                            BB.line_2.set_xy1(Ex, Ey), BB.line_2.set_xy2(n , Ey), BB.Broken_2 := false
                            BB.HL.set_xy(Ex, Ey), BB.HL.set_style(label.style_label_down), BB.HL.set_text('HH'), BB.HL.set_textcolor(PDtxtCss)

                        BB.TP1_hit    := false     
                        BB.TP2_hit    := false                              
                        BB.TP3_hit    := false    
                        BB.Broken     := false
                        BB.Mitigated  := false   
                        BB.scalp      := false
                        BB.PDbroken1  := false
                        BB.PDbroken2  := false

                        if onlyWhenInPDarray and showPDarray
                            BB.PDa_boxA := box.new(Ax, AyMx, Ex +1, mid, bgcolor=color.rgb(248, 153, 132, 90), border_color=color(na)
                             , text = 'Premium PD Array', text_size = size.small, text_color = color.rgb(248, 153, 132, 25)
                             , text_halign = text.align_right, text_valign = text.align_center, text_font_family = font.family_monospace) // , text_wrap= text.wrap_auto
                            BB.PDa_boxB := box.new(Ax, mid , Ex +1,  _y, bgcolor=color.rgb(132, 248, 171, 90), border_color=color(na))

                        // Previous swings
                        cnt = 0, ll1 = low
                        for c = 0 to sz -2
                            getX = aZZ.x.get(c)
                            getY = aZZ.y.get(c)
                            if getY < ll1 and aZZ.d.get(c) == -1 and showSPD
                                getY2 = (mx[n - getX] - low[n - getX]) / 4
                                switch cnt 
                                    0 =>
                                        BB.PDa_box1.set_lefttop    (getX, getY + getY2)
                                        BB.PDaLine1.set_xy1        (getX,        getY )
                                        BB.PDa_box1.set_rightbottom(       n   , getY )
                                        BB.PDaLine1.set_xy2        (       n   , getY )
                                        BB.PDa_box1.set_bgcolor    (       cSwingBr   )
                                        BB.PDaLab_1.set_xy         (       getX, getY )
                                        BB.PDaLab_1.set_size       (       size.small )
                                        BB.PDaLab_1.set_textcolor  (    PDtxtCss )
                                        BB.PDaLab_1.set_text      ('Discount PD Array')
                                        BB.PDaLab_1.set_style(label.style_label_upper_left)

                                        cnt := 1
                                        ll1 := getY
                                    1 => 
                                        if getY + getY2 < ll1
                                            BB.PDa_box2.set_lefttop    (getX, getY + getY2)
                                            BB.PDaLine2.set_xy1        (getX,        getY )
                                            BB.PDa_box2.set_rightbottom(       n   , getY )
                                            BB.PDaLine2.set_xy2        (       n   , getY )
                                            BB.PDa_box2.set_bgcolor    (       cSwingBr   )
                                            BB.PDaLab_2.set_xy         (       getX, getY )
                                            BB.PDaLab_2.set_size       (       size.small )
                                            BB.PDaLab_2.set_textcolor  (    PDtxtCss )
                                            BB.PDaLab_2.set_text      ('Discount PD Array')
                                            BB.PDaLab_2.set_style(label.style_label_upper_left)                                       
                                            cnt := 2
                            if cnt == 2
                                break  

                        I  = red_1_prT - red_1_prB
                        E1 = red_1_prB - (I * R2a / R1a)
                        E2 = red_1_prB - (I * R2b / R1b)
                        E3 = red_1_prB - (I * R2c / R1c)

                        if iTP
                            if not BB.TP1_hit
                                BB.TP1_line.set_xy1(n, E1)  
                                BB.TP1_line.set_xy2(n + 20, E1)  
                            if not BB.TP2_hit
                                BB.TP2_line.set_xy1(n, E2)  
                                BB.TP2_line.set_xy2(n + 20, E2) 
                            if not BB.TP3_hit
                                BB.TP3_line.set_xy1(n, E3)  
                                BB.TP3_line.set_xy2(n + 20, E3) 

                        signals.set(BB_min, true)                        
                        alert('-BB', alert.freq_once_per_bar_close)
                        BB.aLabels.unshift(createLab('d', high, cBB_minB.notransp(), _arrowdn, size.large))
                        
                        break       
                
            MSS.dir := -1 

//-----------------------------------------------------------------------------}
//Calculations
//-----------------------------------------------------------------------------{
draw(len, tpCss)  


lft = BB.BB_boxB.get_left  ()
toppy = BB.BB_boxB.get_top   ()
btm = BB.BB_boxB.get_bottom() 
avg = BB.BB_line.get_y2    ()
l_1 = BB.line_1.get_y2     ()
l_2 = BB.line_2.get_y2     ()
TP1 = BB.TP1_line.get_y2   ()
TP2 = BB.TP2_line.get_y2   ()
TP3 = BB.TP3_line.get_y2   ()

switch BB.dir
    1  => 
        if not BB.Mitigated
            if close < btm
                BB.Mitigated := true 
                signals.set(BB_endBl, true)     
                alert('+BB Mitigated', alert.freq_once_per_bar_close)

                BB.aLabels.unshift(createLab('u', low, color.yellow, _c))
                
                BB.BB_boxB.set_right(n)
                BB.BB_line.set_x2   (n)
            else
                BB.BB_boxB.set_right(n + 8)
                BB.BB_line.set_x2   (n + 8)
                
            BB.TP1_line.set_x2   (n)
            BB.TP2_line.set_x2   (n)
            BB.TP3_line.set_x2   (n)

            if n > BB.BB_boxB.get_left()
                if not BB.Broken
                    if BB.scalp
                        if not BB.TP1_hit and open < TP1 and high > TP1
                            BB.TP1_hit := true
                            signals.set(tpUP1, true)     
                            alert('TP UP 1', alert.freq_once_per_bar)
                            BB.aLabels.unshift(createLab('c', TP1, #ff00dd, _c))
                        if not BB.TP2_hit and open < TP2 and high > TP2
                            BB.TP2_hit := true                                 
                            signals.set(tpUP2, true)     
                            alert('TP UP 2', alert.freq_once_per_bar)
                            BB.aLabels.unshift(createLab('c', TP2, #ff00dd, _c))
                        if not BB.TP3_hit and open < TP3 and high > TP3
                            BB.TP3_hit := true                        
                            signals.set(tpUP3, true)     
                            alert('TP UP 3', alert.freq_once_per_bar)
                            BB.aLabels.unshift(createLab('c', TP3, #ff00dd, _c))
                    switch
                        open > avg and open < toppy and close > toppy => 
                            BB.TP1_hit := false
                            BB.TP2_hit := false
                            BB.TP3_hit := false
                            BB.scalp   := true
                            signals.set(signUP, true)                        
                            alert('signal UP', alert.freq_once_per_bar_close)
                            BB.aLabels.unshift(createLab('u', low, color.lime, _arrowup, size.normal))
                        close < avg and close > btm => 
                            BB.Broken := true
                            BB.scalp  := false
                            signals.set(cnclUP, true)                        
                            alert('cancel UP', alert.freq_once_per_bar_close)
                            BB.aLabels.unshift(createLab('u', low, color.orange, _x))
                else
                    // reset
                    if not tillFirstBreak and close > toppy 
                        BB.Broken := false  
                        BB.scalp := true 
                        signals.set(BBplus, true)                        
                        alert('+BB (R)', alert.freq_once_per_bar_close)
                        BB.aLabels.unshift(createLab('u', low, color.blue, 'R', size.normal)) 

        if not BB.Broken_1
            BB.line_1.set_x2(n)
            if close < l_1
                BB.Broken_1 := true
                signals.set(LL1break, true)                        
                alert('LL 1 break', alert.freq_once_per_bar_close)
                if showBreaks
                    BB.aLabels.unshift(createLab('c', low, #c00000, _c))
        if not BB.Broken_2 
            BB.line_2.set_x2(n)
            if close < l_2
                BB.Broken_2 := true                     
                signals.set(LL2break, true)                        
                alert('LL 2 break', alert.freq_once_per_bar_close)
                if showBreaks
                    BB.aLabels.unshift(createLab('c', low, #c00000, _c))

        if not BB.PDbroken1
            BB.PDa_box1.set_right(n)            
            BB.PDaLine1.set_x2   (n)
            if close > BB.PDa_box1.get_top() and n > BB.PDa_box1.get_left()
                BB.PDbroken1 := true             
                signals.set(SW1breakUP, true)                       
                alert('Swing UP 1 break', alert.freq_once_per_bar_close)
                if showBreaks
                    BB.aLabels.unshift(createLab('c', high, #c00000, _c))
        if not BB.PDbroken2
            BB.PDa_box2.set_right(n)            
            BB.PDaLine2.set_x2   (n)
            if close > BB.PDa_box2.get_top() and n > BB.PDa_box2.get_left()
                BB.PDbroken2 := true                 
                signals.set(SW2breakUP, true)                        
                alert('Swing UP 2 break', alert.freq_once_per_bar_close)
                if showBreaks
                    BB.aLabels.unshift(createLab('c', high, #c00000, _c))

    -1 =>
        if not BB.Mitigated
            if close > toppy
                BB.Mitigated := true 
                signals.set(BB_endBr, true)     
                alert('-BB Mitigated', alert.freq_once_per_bar_close)
                if showBreaks
                    BB.aLabels.unshift(createLab('d', high, cBB_minB.notransp(), _c))
                BB.BB_boxB.set_right(n)
                BB.BB_line.set_x2   (n)
            else
                BB.BB_boxB.set_right(n + 8)
                BB.BB_line.set_x2   (n + 8)

            BB.TP1_line.set_x2   (n)
            BB.TP2_line.set_x2   (n)
            BB.TP3_line.set_x2   (n)

            if n > BB.BB_boxB.get_left()
                if not BB.Broken
                    if BB.scalp
                        if not BB.TP1_hit and open > TP1 and low < TP1
                            BB.TP1_hit := true                       
                            signals.set(tpDN1, true)                             
                            alert('TP DN 1', alert.freq_once_per_bar)
                            BB.aLabels.unshift(createLab('c', TP1, #ff00dd, _c))
                        if not BB.TP2_hit and open > TP2 and low < TP2
                            BB.TP2_hit := true                                 
                            signals.set(tpDN2, true)                             
                            alert('TP DN 2', alert.freq_once_per_bar)               
                            BB.aLabels.unshift(createLab('c', TP2, #ff00dd, _c))
                        if not BB.TP3_hit and open > TP3 and low < TP3
                            BB.TP3_hit := true                                    
                            signals.set(tpDN3, true)                             
                            alert('TP DN 3', alert.freq_once_per_bar)       
                            BB.aLabels.unshift(createLab('c', TP3, #ff00dd, _c))
                    switch
                        open < avg and open > btm and close < btm => 
                            BB.TP1_hit := false
                            BB.TP2_hit := false
                            BB.TP3_hit := false
                            BB.scalp   := true
                            signals.set(signDN, true)
                            alert('signal DN', alert.freq_once_per_bar_close)
                            BB.aLabels.unshift(createLab('d', high, color.orange, _arrowdn, size.normal))
                        close > avg and close < toppy => 
                            BB.Broken := true
                            BB.scalp  := false
                            signals.set(cnclDN, true)
                            alert('cancel DN', alert.freq_once_per_bar_close)
                            BB.aLabels.unshift(createLab('d', high, color.red   , _x))
                else
                    // reset
                    if not tillFirstBreak and close < btm 
                        BB.Broken := false 
                        BB.scalp  := true 
                        signals.set(BB_min, true)                        
                        alert('-BB (R)', alert.freq_once_per_bar_close)                        
                        BB.aLabels.unshift(createLab('d', high, color.blue, 'R', size.normal))

        if not BB.Broken_1             
            BB.line_1.set_x2(n)
            if close > l_1                 
                BB.Broken_1 := true
                signals.set(HH1break, true)                        
                alert('HH 1 break', alert.freq_once_per_bar_close)
                if showBreaks
                    BB.aLabels.unshift(createLab('c', high, #c00000, _c))
        if not BB.Broken_2             
            BB.line_2.set_x2(n)
            if close > l_2
                BB.Broken_2 := true
                signals.set(HH2break, true)                        
                alert('HH 2 break', alert.freq_once_per_bar_close)
                if showBreaks
                    BB.aLabels.unshift(createLab('c', high, #c00000, _c))

        if not BB.PDbroken1
            BB.PDa_box1.set_right(n)
            BB.PDaLine1.set_x2   (n)
            if close < BB.PDa_box1.get_bottom() and n > BB.PDa_box1.get_left()
                BB.PDbroken1 := true
                signals.set(SW1breakDN, true)                        
                alert('Swing DN 1 break', alert.freq_once_per_bar_close)
                if showBreaks
                    BB.aLabels.unshift(createLab('c', low, #c00000, _c))
        if not BB.PDbroken2
            BB.PDa_box2.set_right(n)            
            BB.PDaLine2.set_x2   (n)
            if close < BB.PDa_box2.get_bottom() and n > BB.PDa_box2.get_left()
                BB.PDbroken2 := true
                signals.set(SW2breakDN, true)                        
                alert('Swing DN 2 break', alert.freq_once_per_bar_close)
                if showBreaks
                    BB.aLabels.unshift(createLab('c', low, #c00000, _c))
  
//-----------------------------------------------------------------------------}
//Alerts
//-----------------------------------------------------------------------------{
alertcondition(signals.get(BBplus    ), ' 1. +BB'             , '1. +BB'             )
alertcondition(signals.get(signUP    ), ' 2. signal UP'       , '2. signal UP'       )
alertcondition(signals.get(tpUP1     ), ' 3. TP UP 1'         , '3. TP UP 1'         )
alertcondition(signals.get(tpUP2     ), ' 3. TP UP 2'         , '3. TP UP 2'         )
alertcondition(signals.get(tpUP3     ), ' 3. TP UP 3'         , '3. TP UP 3'         )
alertcondition(signals.get(cnclUP    ), ' 4. cancel UP'       , '4. cancel UP'       )
alertcondition(signals.get(BB_endBl  ), ' 5. +BB Mitigated'   , '5. +BB Mitigated'   )
alertcondition(signals.get(LL1break  ), ' 6. LL 1 Break'      , '6. LL 1 Break'      )
alertcondition(signals.get(LL2break  ), ' 6. LL 2 Break'      , '6. LL 2 Break'      )
alertcondition(signals.get(SW1breakUP), ' 7. Swing UP 1 Break', '7. Swing UP 1 Break')
alertcondition(signals.get(SW2breakUP), ' 7. Swing UP 2 Break', '7. Swing UP 2 Break')

alertcondition(signals.get(BB_min    ),  '1. -BB'             , '1. -BB'             )
alertcondition(signals.get(signDN    ),  '2. signal DN'       , '2. signal DN'       )
alertcondition(signals.get(tpDN1     ),  '3. TP DN 1'         , '3. TP DN 1'         )
alertcondition(signals.get(tpDN2     ),  '3. TP DN 2'         , '3. TP DN 2'         )
alertcondition(signals.get(tpDN3     ),  '3. TP DN 3'         , '3. TP DN 3'         )
alertcondition(signals.get(cnclDN    ),  '4. cancel DN'       , '4. cancel DN'       )
alertcondition(signals.get(BB_endBr  ),  '5. -BB Mitigated'   , '5. -BB Mitigated'   )
alertcondition(signals.get(HH1break  ),  '6. HH 1 Break'      , '6. HH 1 Break'      )
alertcondition(signals.get(HH2break  ),  '6. HH 2 Break'      , '6. HH 2 Break'      )
alertcondition(signals.get(SW1breakDN),  '7. Swing DN 1 Break', '7. Swing DN 1 Break')
alertcondition(signals.get(SW2breakDN),  '7. Swing DN 2 Break', '7. Swing DN 2 Break')

//-----------------------------------------------------------------------------}




///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
////////////////// TradeforOpp HTF Liquidity Dashboard   //////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////



// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © tradeforopp

//@version=5
// indicator("HTF Liquidity Dashboard [TFO]", "HTF Liquidity Dashboard [TFO]", true, max_labels_count = 500, max_lines_count = 500)


// ------------------------------ Inputs ------------------------------
var g_SET = "Settings"
show_d = input.bool(true, "Daily", inline = "DWM", tooltip = "Select which timeframes should be displayed with their highs and lows", group = g_SET)
show_w = input.bool(true, "Weekly", inline = "DWM", group = g_SET)
show_m = input.bool(true, "Monthly", inline = "DWM", group = g_SET)
labels = input.bool(false, "Show Sweep Labels", inline = "LBL", tooltip = "Show labels when any of the selected symbols sweep their previous highs and lows", group = g_SET)
label_bg = input.color(color.black, "", inline = "LBL", group = g_SET)
label_text = input.color(color.white, "", inline = "LBL", group = g_SET)
text_size = input.string("Normal", "Text Size", options = ['Auto', 'Tiny', 'Small', 'Normal', 'Large', 'Huge'], tooltip = "Label and table text size", group = g_SET)
dash_text = input.string("Custom", "Dashboard Text", options = ['Custom', 'Levels'], tooltip = "Custom will show the strings below in the dashboard cells. Levels will show the actual numerical highs and lows", group = g_SET)
exceed_str = input.string("✔", "Swept & Exceeded ‏", inline = "XC", tooltip = "When price takes a high and is currently trading above it, or takes a low and is currently trading below it", group = g_SET)
failed_str = input.string("❌", "Swept & Reversed ‏ ‏", inline = "RV", tooltip = "When price takes a high but is currently trading back below it, or takes a low and is currently trading back above it", group = g_SET)
exceed_color = input.color(color.new(#089981, 30), "", inline = "XC", group = g_SET)
failed_color = input.color(color.new(#f23645, 30), "", inline = "RV", group = g_SET)

var g_CC = "Current Chart"
show_c = input.bool(true, "Show Levels", tooltip = "Show previous highs and lows of the current chart symbol", group = g_CC)
plimit = input.int(3, "Session Limit", 1, tooltip = "This many highs and lows will be stored and shown on the current chart (per timeframe)", group = g_CC)
before_color = input.color(#000000, "Colors Before / After Sweep", inline = "CCC", tooltip = "Levels will be drawn as the left color, but will change to the right color once price trades through them", group = g_CC)
after_color = input.color(#f23645, "", inline = "CCC", group = g_CC)
d_style = input.string('Dotted', "Daily ‏ ‏ ‏ ‏", options = ['Solid', 'Dashed', 'Dotted'], inline = "CCD", group = g_CC)
d_width = input.int(1, "", 0, inline = "CCD", group = g_CC)
w_style = input.string('Dashed', "Weekly ‏", options = ['Solid', 'Dashed', 'Dotted'], inline = "CCW", group = g_CC)
w_width = input.int(1, "", 0, inline = "CCW", group = g_CC)
m_style = input.string('Solid', "Monthly", options = ['Solid', 'Dashed', 'Dotted'], inline = "CCM", group = g_CC)
m_width = input.int(1, "", 0, inline = "CCM", group = g_CC)

var g_SYM = "Symbols"
use_s0 = input.bool(true, "", inline = "s0", group = g_SYM)
use_s1 = input.bool(true, "", inline = "s1", group = g_SYM)
use_s2 = input.bool(true, "", inline = "s2", group = g_SYM)
use_s3 = input.bool(true, "", inline = "s3", group = g_SYM)
use_s4 = input.bool(true, "", inline = "s4", group = g_SYM)
use_s5 = input.bool(true, "", inline = "s5", group = g_SYM)
use_s6 = input.bool(true, "", inline = "s6", group = g_SYM)
use_s7 = input.bool(true, "", inline = "s7", group = g_SYM)
use_s8 = input.bool(true, "", inline = "s8", group = g_SYM)

s0 = input.symbol("ES1!", "", inline = "s0", group = g_SYM)
s1 = input.symbol("NQ1!", "", inline = "s1", group = g_SYM)
s2 = input.symbol("YM1!", "", inline = "s2", group = g_SYM)
s3 = input.symbol("CL1!", "", inline = "s3", group = g_SYM)
s4 = input.symbol("GC1!", "", inline = "s4", group = g_SYM)
s5 = input.symbol("EURUSD", "", inline = "s5", group = g_SYM)
s6 = input.symbol("GBPUSD", "", inline = "s6", group = g_SYM)
s7 = input.symbol("USDJPY", "", inline = "s7", group = g_SYM)
s8 = input.symbol("AUDUSD", "", inline = "s8", group = g_SYM)

var g_TBL = "Table Style"
table_position = input.string('Top Right', "Table Position", options = ['Bottom Center', 'Bottom Left', 'Bottom Right', 'Middle Center', 'Middle Left', 'Middle Right', 'Top Center', 'Top Left', 'Top Right'], group = g_TBL)
tbl_bg = input.color(color.white, "Background Color", group = g_TBL)
tbl_bd = input.color(color.black, "Border Color", group = g_TBL)
tbl_fr = input.color(color.black, "Frame Color", group = g_TBL)
tbl_fr_w = input.int(2, "Frame Width", 1, group = g_TBL)
tbl_bd_w = input.int(1, "Border Width", 1, group = g_TBL)
// ------------------------------ Inputs ------------------------------


// ------------------------------ Functions ------------------------------
get_name(x) =>
    array.get(str.split(x, ":"), 1)

get_size(x) =>
    result = switch x
        'Auto' => size.auto
        'Tiny' => size.tiny
        'Small' => size.small
        'Normal' => size.normal
        'Large' => size.large
        'Huge' => size.huge

get_line_style(x) =>
    result = switch x
        'Solid' => line.style_solid
        'Dashed' => line.style_dashed
        'Dotted' => line.style_dotted

get_table_position(x) =>
    result = switch x
        "Bottom Center" => position.bottom_center
        "Bottom Left" => position.bottom_left
        "Bottom Right" => position.bottom_right
        "Middle Center" => position.middle_center
        "Middle Left" => position.middle_left
        "Middle Right" => position.middle_right
        "Top Center" => position.top_center
        "Top Left" => position.top_left
        "Top Right" => position.top_right

update_arrays(o, h_arr, l_arr, h, l) =>
    if o != o[1]
        h_arr.unshift(h[1])
        l_arr.unshift(l[1])
    if h_arr.size() > 1
        h_arr.pop()
        l_arr.pop()

evaluate(ph, ch, pl, cl, cc) =>
    color _hcolor = na
    string _hstring = (dash_text == 'Levels') ? str.tostring(ph) : "-"
    if ch > ph
        if cc > ph
            _hcolor := exceed_color
            if not (dash_text == 'Levels')
                _hstring := exceed_str
        else 
            _hcolor := failed_color
            if not (dash_text == 'Levels')
                _hstring := failed_str
    
    color _lcolor = na
    string _lstring = (dash_text == 'Levels') ? str.tostring(pl) : "-"
    if cl < pl
        if cc < pl
            _lcolor := exceed_color
            if not (dash_text == 'Levels')
                _lstring := exceed_str
        else 
            _lcolor := failed_color
            if not (dash_text == 'Levels')
                _lstring := failed_str
    [_hstring, _hcolor, _lstring, _lcolor]

update_table(_table, _col, _row, _use, _name, _h, _l, _c, _highs, _lows) =>
    if _use and _highs.size() > 0
        _size = get_size(text_size)
        [_hstring, _hcolor, _lstring, _lcolor] = evaluate(_highs.get(0), _h, _lows.get(0), _l, _c)
        table.cell(_table, 0, _row, str.tostring(get_name(_name)), text_size = _size) 
        table.cell(_table, _col, _row, _hstring, bgcolor = _hcolor, text_size = _size)
        table.cell(_table, _col + 1, _row, _lstring, bgcolor = _lcolor, text_size = _size)

check_raids(_s, _use, _ph, _pl, _ch, _cl, _rah, _ral, _ri, _tf) =>
    if _ph.size() > 0 and _use
        took_highs = _ch > _ph.get(0)
        took_lows = _cl < _pl.get(0)
        _name = get_name(_s)
        if took_highs and not _rah.get(_ri)
            _rah.set(_ri, true)
            _text = _name + " Took P" + _tf + "H"
            alert(_text, freq = alert.freq_once_per_bar)
            if labels
                label.new(bar_index, high, _text, style = label.style_label_down, color = label_bg, textcolor = label_text, size = get_size(text_size))
        if took_lows and not _ral.get(_ri)
            _ral.set(_ri, true)
            _text = _name + " Took P" + _tf + "L"
            alert(_text, freq = alert.freq_once_per_bar)
            if labels
                label.new(bar_index, low, _text, style = label.style_label_up, color = label_bg, textcolor = label_text, size = get_size(text_size))
                
reset_raid(_d, _ah, _al) =>
    result = false    
    if _d != _d[1]
        for i = 0 to _ah.size() - 1
            _ah.set(i, false)
        for i = 0 to _al.size() - 1
            _al.set(i, false)

chart_pivot(_open, _high, _low, _ph, _pl, _hline, _lline, _hlabel, _llabel, _tf, _style, _width) =>
    if _ph.size() > 0
        if _open != _open[1]
            _hline.unshift(line.new(bar_index, _ph.get(0), bar_index, _ph.get(0), color = before_color, width = _width, style = _style))
            _lline.unshift(line.new(bar_index, _pl.get(0), bar_index, _pl.get(0), color = before_color, width = _width, style = _style))

            _hlabel.set_xy(bar_index, _ph.get(0))
            _llabel.set_xy(bar_index, _pl.get(0))
            
            _hlabel.set_text("P" + _tf + "H")
            _llabel.set_text("P" + _tf + "L")
            
            _hlabel.set_textcolor(before_color)
            _llabel.set_textcolor(before_color)
        else
            _hline.get(0).set_x2(bar_index)
            _lline.get(0).set_x2(bar_index)
            
            _hlabel.set_x(bar_index)
            _llabel.set_x(bar_index)
            if _high > _hline.get(0).get_y1()
                _hline.get(0).set_color(after_color)
                _hlabel.set_textcolor(after_color)
            if _low < _lline.get(0).get_y1()
                _lline.get(0).set_color(after_color)
                _llabel.set_textcolor(after_color)
        if _hline.size() > plimit
            line.delete(_hline.pop())
            line.delete(_lline.pop())
// ------------------------------ Functions ------------------------------


// ------------------------------ DWM Data ------------------------------
// chart timeframe
[s0c_o, s0c_h, s0c_l, s0c_c] = request.security(s0, "", [open, high, low, close], barmerge.gaps_off, barmerge.lookahead_on)
[s1c_o, s1c_h, s1c_l, s1c_c] = request.security(s1, "", [open, high, low, close], barmerge.gaps_off, barmerge.lookahead_on)
[s2c_o, s2c_h, s2c_l, s2c_c] = request.security(s2, "", [open, high, low, close], barmerge.gaps_off, barmerge.lookahead_on)
[s3c_o, s3c_h, s3c_l, s3c_c] = request.security(s3, "", [open, high, low, close], barmerge.gaps_off, barmerge.lookahead_on)
[s4c_o, s4c_h, s4c_l, s4c_c] = request.security(s4, "", [open, high, low, close], barmerge.gaps_off, barmerge.lookahead_on)
[s5c_o, s5c_h, s5c_l, s5c_c] = request.security(s5, "", [open, high, low, close], barmerge.gaps_off, barmerge.lookahead_on)
[s6c_o, s6c_h, s6c_l, s6c_c] = request.security(s6, "", [open, high, low, close], barmerge.gaps_off, barmerge.lookahead_on)
[s7c_o, s7c_h, s7c_l, s7c_c] = request.security(s7, "", [open, high, low, close], barmerge.gaps_off, barmerge.lookahead_on)
[s8c_o, s8c_h, s8c_l, s8c_c] = request.security(s8, "", [open, high, low, close], barmerge.gaps_off, barmerge.lookahead_on)

// daily timeframe
[s0d_o, s0d_h, s0d_l, s0d_c] = request.security(s0, "D", [open, high, low, close], barmerge.gaps_off, barmerge.lookahead_on)
[s1d_o, s1d_h, s1d_l, s1d_c] = request.security(s1, "D", [open, high, low, close], barmerge.gaps_off, barmerge.lookahead_on)
[s2d_o, s2d_h, s2d_l, s2d_c] = request.security(s2, "D", [open, high, low, close], barmerge.gaps_off, barmerge.lookahead_on)
[s3d_o, s3d_h, s3d_l, s3d_c] = request.security(s3, "D", [open, high, low, close], barmerge.gaps_off, barmerge.lookahead_on)
[s4d_o, s4d_h, s4d_l, s4d_c] = request.security(s4, "D", [open, high, low, close], barmerge.gaps_off, barmerge.lookahead_on)
[s5d_o, s5d_h, s5d_l, s5d_c] = request.security(s5, "D", [open, high, low, close], barmerge.gaps_off, barmerge.lookahead_on)
[s6d_o, s6d_h, s6d_l, s6d_c] = request.security(s6, "D", [open, high, low, close], barmerge.gaps_off, barmerge.lookahead_on)
[s7d_o, s7d_h, s7d_l, s7d_c] = request.security(s7, "D", [open, high, low, close], barmerge.gaps_off, barmerge.lookahead_on)
[s8d_o, s8d_h, s8d_l, s8d_c] = request.security(s8, "D", [open, high, low, close], barmerge.gaps_off, barmerge.lookahead_on)

// weekly timeframe
[s0w_o, s0w_h, s0w_l, s0w_c] = request.security(s0, "W", [open, high, low, close], barmerge.gaps_off, barmerge.lookahead_on)
[s1w_o, s1w_h, s1w_l, s1w_c] = request.security(s1, "W", [open, high, low, close], barmerge.gaps_off, barmerge.lookahead_on)
[s2w_o, s2w_h, s2w_l, s2w_c] = request.security(s2, "W", [open, high, low, close], barmerge.gaps_off, barmerge.lookahead_on)
[s3w_o, s3w_h, s3w_l, s3w_c] = request.security(s3, "W", [open, high, low, close], barmerge.gaps_off, barmerge.lookahead_on)
[s4w_o, s4w_h, s4w_l, s4w_c] = request.security(s4, "W", [open, high, low, close], barmerge.gaps_off, barmerge.lookahead_on)
[s5w_o, s5w_h, s5w_l, s5w_c] = request.security(s5, "W", [open, high, low, close], barmerge.gaps_off, barmerge.lookahead_on)
[s6w_o, s6w_h, s6w_l, s6w_c] = request.security(s6, "W", [open, high, low, close], barmerge.gaps_off, barmerge.lookahead_on)
[s7w_o, s7w_h, s7w_l, s7w_c] = request.security(s7, "W", [open, high, low, close], barmerge.gaps_off, barmerge.lookahead_on)
[s8w_o, s8w_h, s8w_l, s8w_c] = request.security(s8, "W", [open, high, low, close], barmerge.gaps_off, barmerge.lookahead_on)

// monthly timeframe
[s0m_o, s0m_h, s0m_l, s0m_c] = request.security(s0, "M", [open, high, low, close], barmerge.gaps_off, barmerge.lookahead_on)
[s1m_o, s1m_h, s1m_l, s1m_c] = request.security(s1, "M", [open, high, low, close], barmerge.gaps_off, barmerge.lookahead_on)
[s2m_o, s2m_h, s2m_l, s2m_c] = request.security(s2, "M", [open, high, low, close], barmerge.gaps_off, barmerge.lookahead_on)
[s3m_o, s3m_h, s3m_l, s3m_c] = request.security(s3, "M", [open, high, low, close], barmerge.gaps_off, barmerge.lookahead_on)
[s4m_o, s4m_h, s4m_l, s4m_c] = request.security(s4, "M", [open, high, low, close], barmerge.gaps_off, barmerge.lookahead_on)
[s5m_o, s5m_h, s5m_l, s5m_c] = request.security(s5, "M", [open, high, low, close], barmerge.gaps_off, barmerge.lookahead_on)
[s6m_o, s6m_h, s6m_l, s6m_c] = request.security(s6, "M", [open, high, low, close], barmerge.gaps_off, barmerge.lookahead_on)
[s7m_o, s7m_h, s7m_l, s7m_c] = request.security(s7, "M", [open, high, low, close], barmerge.gaps_off, barmerge.lookahead_on)
[s8m_o, s8m_h, s8m_l, s8m_c] = request.security(s8, "M", [open, high, low, close], barmerge.gaps_off, barmerge.lookahead_on)

// current chart symbol
[s9c_o, s9c_h, s9c_l, s9c_c] = request.security(syminfo.tickerid, "", [open, high, low, close], barmerge.gaps_off, barmerge.lookahead_on)
[s9d_o, s9d_h, s9d_l, s9d_c] = request.security(syminfo.tickerid, "D", [open, high, low, close], barmerge.gaps_off, barmerge.lookahead_on)
[s9w_o, s9w_h, s9w_l, s9w_c] = request.security(syminfo.tickerid, "W", [open, high, low, close], barmerge.gaps_off, barmerge.lookahead_on)
[s9m_o, s9m_h, s9m_l, s9m_c] = request.security(syminfo.tickerid, "M", [open, high, low, close], barmerge.gaps_off, barmerge.lookahead_on)
// ------------------------------ DWM Data ------------------------------


// ------------------------------ Arrays ------------------------------
// daily
var s00d_highs = array.new_float()
var s0d_highs = array.new_float()
var s1d_highs = array.new_float()
var s2d_highs = array.new_float()
var s3d_highs = array.new_float()
var s4d_highs = array.new_float()
var s5d_highs = array.new_float()
var s6d_highs = array.new_float()
var s7d_highs = array.new_float()
var s8d_highs = array.new_float()
var s9d_highs = array.new_float()

var s00d_lows = array.new_float()
var s0d_lows = array.new_float()
var s1d_lows = array.new_float()
var s2d_lows = array.new_float()
var s3d_lows = array.new_float()
var s4d_lows = array.new_float()
var s5d_lows = array.new_float()
var s6d_lows = array.new_float()
var s7d_lows = array.new_float()
var s8d_lows = array.new_float()
var s9d_lows = array.new_float()

var s0d_rh = array.new_bool(10, false)
var s1d_rh = array.new_bool(10, false)
var s2d_rh = array.new_bool(10, false)
var s3d_rh = array.new_bool(10, false)
var s4d_rh = array.new_bool(10, false)
var s5d_rh = array.new_bool(10, false)
var s6d_rh = array.new_bool(10, false)
var s7d_rh = array.new_bool(10, false)
var s8d_rh = array.new_bool(10, false)
var s9d_rh = array.new_bool(10, false)

var s0d_rl = array.new_bool(10, false)
var s1d_rl = array.new_bool(10, false)
var s2d_rl = array.new_bool(10, false)
var s3d_rl = array.new_bool(10, false)
var s4d_rl = array.new_bool(10, false)
var s5d_rl = array.new_bool(10, false)
var s6d_rl = array.new_bool(10, false)
var s7d_rl = array.new_bool(10, false)
var s8d_rl = array.new_bool(10, false)
var s9d_rl = array.new_bool(10, false)

// weekly
var s00w_highs = array.new_float()
var s0w_highs = array.new_float()
var s1w_highs = array.new_float()
var s2w_highs = array.new_float()
var s3w_highs = array.new_float()
var s4w_highs = array.new_float()
var s5w_highs = array.new_float()
var s6w_highs = array.new_float()
var s7w_highs = array.new_float()
var s8w_highs = array.new_float()
var s9w_highs = array.new_float()

var s00w_lows = array.new_float()
var s0w_lows = array.new_float()
var s1w_lows = array.new_float()
var s2w_lows = array.new_float()
var s3w_lows = array.new_float()
var s4w_lows = array.new_float()
var s5w_lows = array.new_float()
var s6w_lows = array.new_float()
var s7w_lows = array.new_float()
var s8w_lows = array.new_float()
var s9w_lows = array.new_float()

var s0w_rh = array.new_bool(10, false)
var s1w_rh = array.new_bool(10, false)
var s2w_rh = array.new_bool(10, false)
var s3w_rh = array.new_bool(10, false)
var s4w_rh = array.new_bool(10, false)
var s5w_rh = array.new_bool(10, false)
var s6w_rh = array.new_bool(10, false)
var s7w_rh = array.new_bool(10, false)
var s8w_rh = array.new_bool(10, false)
var s9w_rh = array.new_bool(10, false)

var s0w_rl = array.new_bool(10, false)
var s1w_rl = array.new_bool(10, false)
var s2w_rl = array.new_bool(10, false)
var s3w_rl = array.new_bool(10, false)
var s4w_rl = array.new_bool(10, false)
var s5w_rl = array.new_bool(10, false)
var s6w_rl = array.new_bool(10, false)
var s7w_rl = array.new_bool(10, false)
var s8w_rl = array.new_bool(10, false)
var s9w_rl = array.new_bool(10, false)

// monthly
var s00m_highs = array.new_float()
var s0m_highs = array.new_float()
var s1m_highs = array.new_float()
var s2m_highs = array.new_float()
var s3m_highs = array.new_float()
var s4m_highs = array.new_float()
var s5m_highs = array.new_float()
var s6m_highs = array.new_float()
var s7m_highs = array.new_float()
var s8m_highs = array.new_float()
var s9m_highs = array.new_float()

var s00m_lows = array.new_float()
var s0m_lows = array.new_float()
var s1m_lows = array.new_float()
var s2m_lows = array.new_float()
var s3m_lows = array.new_float()
var s4m_lows = array.new_float()
var s5m_lows = array.new_float()
var s6m_lows = array.new_float()
var s7m_lows = array.new_float()
var s8m_lows = array.new_float()
var s9m_lows = array.new_float()

var s0m_rh = array.new_bool(10, false)
var s1m_rh = array.new_bool(10, false)
var s2m_rh = array.new_bool(10, false)
var s3m_rh = array.new_bool(10, false)
var s4m_rh = array.new_bool(10, false)
var s5m_rh = array.new_bool(10, false)
var s6m_rh = array.new_bool(10, false)
var s7m_rh = array.new_bool(10, false)
var s8m_rh = array.new_bool(10, false)
var s9m_rh = array.new_bool(10, false)

var s0m_rl = array.new_bool(10, false)
var s1m_rl = array.new_bool(10, false)
var s2m_rl = array.new_bool(10, false)
var s3m_rl = array.new_bool(10, false)
var s4m_rl = array.new_bool(10, false)
var s5m_rl = array.new_bool(10, false)
var s6m_rl = array.new_bool(10, false)
var s7m_rl = array.new_bool(10, false)
var s8m_rl = array.new_bool(10, false)
var s9m_rl = array.new_bool(10, false)

//current chart
var pdh = array.new_line()
var pwh = array.new_line()
var pmh = array.new_line()

var pdl = array.new_line()
var pwl = array.new_line()
var pml = array.new_line()

var pdh_label = label.new(na, na, style = label.style_label_left, color = #ffffff00, textcolor = before_color, size = get_size(text_size))
var pwh_label = label.new(na, na, style = label.style_label_left, color = #ffffff00, textcolor = before_color, size = get_size(text_size))
var pmh_label = label.new(na, na, style = label.style_label_left, color = #ffffff00, textcolor = before_color, size = get_size(text_size))

var pdl_label = label.new(na, na, style = label.style_label_left, color = #ffffff00, textcolor = before_color, size = get_size(text_size))
var pwl_label = label.new(na, na, style = label.style_label_left, color = #ffffff00, textcolor = before_color, size = get_size(text_size))
var pml_label = label.new(na, na, style = label.style_label_left, color = #ffffff00, textcolor = before_color, size = get_size(text_size))
// ------------------------------ Arrays ------------------------------


// ------------------------------ Update Arrays ------------------------------
// daily 
update_arrays(s0d_o, s0d_highs, s0d_lows, s0d_h, s0d_l)
update_arrays(s1d_o, s1d_highs, s1d_lows, s1d_h, s1d_l)
update_arrays(s2d_o, s2d_highs, s2d_lows, s2d_h, s2d_l)
update_arrays(s3d_o, s3d_highs, s3d_lows, s3d_h, s3d_l)
update_arrays(s4d_o, s4d_highs, s4d_lows, s4d_h, s4d_l)
update_arrays(s5d_o, s5d_highs, s5d_lows, s5d_h, s5d_l)
update_arrays(s6d_o, s6d_highs, s6d_lows, s6d_h, s6d_l)
update_arrays(s7d_o, s7d_highs, s7d_lows, s7d_h, s7d_l)
update_arrays(s8d_o, s8d_highs, s8d_lows, s8d_h, s8d_l)
update_arrays(s9d_o, s9d_highs, s9d_lows, s9d_h, s9d_l)

// weekly 
update_arrays(s0w_o, s0w_highs, s0w_lows, s0w_h, s0w_l)
update_arrays(s1w_o, s1w_highs, s1w_lows, s1w_h, s1w_l)
update_arrays(s2w_o, s2w_highs, s2w_lows, s2w_h, s2w_l)
update_arrays(s3w_o, s3w_highs, s3w_lows, s3w_h, s3w_l)
update_arrays(s4w_o, s4w_highs, s4w_lows, s4w_h, s4w_l)
update_arrays(s5w_o, s5w_highs, s5w_lows, s5w_h, s5w_l)
update_arrays(s6w_o, s6w_highs, s6w_lows, s6w_h, s6w_l)
update_arrays(s7w_o, s7w_highs, s7w_lows, s7w_h, s7w_l)
update_arrays(s8w_o, s8w_highs, s8w_lows, s8w_h, s8w_l)
update_arrays(s9w_o, s9w_highs, s9w_lows, s9w_h, s9w_l)

// monthly 
update_arrays(s0m_o, s0m_highs, s0m_lows, s0m_h, s0m_l)
update_arrays(s1m_o, s1m_highs, s1m_lows, s1m_h, s1m_l)
update_arrays(s2m_o, s2m_highs, s2m_lows, s2m_h, s2m_l)
update_arrays(s3m_o, s3m_highs, s3m_lows, s3m_h, s3m_l)
update_arrays(s4m_o, s4m_highs, s4m_lows, s4m_h, s4m_l)
update_arrays(s5m_o, s5m_highs, s5m_lows, s5m_h, s5m_l)
update_arrays(s6m_o, s6m_highs, s6m_lows, s6m_h, s6m_l)
update_arrays(s7m_o, s7m_highs, s7m_lows, s7m_h, s7m_l)
update_arrays(s8m_o, s8m_highs, s8m_lows, s8m_h, s8m_l)
update_arrays(s9m_o, s9m_highs, s9m_lows, s9m_h, s9m_l)
// ------------------------------ Update Arrays ------------------------------


// ------------------------------ Reset Raids ------------------------------
// daily
reset_raid(s0d_o, s0d_rh, s0d_rl)
reset_raid(s1d_o, s1d_rh, s1d_rl)
reset_raid(s2d_o, s2d_rh, s2d_rl)
reset_raid(s3d_o, s3d_rh, s3d_rl)
reset_raid(s4d_o, s4d_rh, s4d_rl)
reset_raid(s5d_o, s5d_rh, s5d_rl)
reset_raid(s6d_o, s6d_rh, s6d_rl)
reset_raid(s7d_o, s7d_rh, s7d_rl)
reset_raid(s8d_o, s8d_rh, s8d_rl)
reset_raid(s9d_o, s9d_rh, s9d_rl)

// weeks
reset_raid(s0w_o, s0w_rh, s0w_rl)
reset_raid(s1w_o, s1w_rh, s1w_rl)
reset_raid(s2w_o, s2w_rh, s2w_rl)
reset_raid(s3w_o, s3w_rh, s3w_rl)
reset_raid(s4w_o, s4w_rh, s4w_rl)
reset_raid(s5w_o, s5w_rh, s5w_rl)
reset_raid(s6w_o, s6w_rh, s6w_rl)
reset_raid(s7w_o, s7w_rh, s7w_rl)
reset_raid(s8w_o, s8w_rh, s8w_rl)
reset_raid(s9w_o, s9w_rh, s9w_rl)

// monthly
reset_raid(s0m_o, s0m_rh, s0m_rl)
reset_raid(s1m_o, s1m_rh, s1m_rl)
reset_raid(s2m_o, s2m_rh, s2m_rl)
reset_raid(s3m_o, s3m_rh, s3m_rl)
reset_raid(s4m_o, s4m_rh, s4m_rl)
reset_raid(s5m_o, s5m_rh, s5m_rl)
reset_raid(s6m_o, s6m_rh, s6m_rl)
reset_raid(s7m_o, s7m_rh, s7m_rl)
reset_raid(s8m_o, s8m_rh, s8m_rl)
reset_raid(s9m_o, s9m_rh, s9m_rl)
// ------------------------------ Reset Raids ------------------------------


// ------------------------------ Check Raids ------------------------------
// daily
check_raids(s0, use_s0 and show_d, s0d_highs, s0d_lows, s0c_h, s0c_l, s0d_rh, s0d_rl, 0, "D")
check_raids(s1, use_s1 and show_d, s1d_highs, s1d_lows, s1c_h, s1c_l, s1d_rh, s1d_rl, 1, "D")
check_raids(s2, use_s2 and show_d, s2d_highs, s2d_lows, s2c_h, s2c_l, s2d_rh, s2d_rl, 2, "D")
check_raids(s3, use_s3 and show_d, s3d_highs, s3d_lows, s3c_h, s3c_l, s3d_rh, s3d_rl, 3, "D")
check_raids(s4, use_s4 and show_d, s4d_highs, s4d_lows, s4c_h, s4c_l, s4d_rh, s4d_rl, 4, "D")
check_raids(s5, use_s5 and show_d, s5d_highs, s5d_lows, s5c_h, s5c_l, s5d_rh, s5d_rl, 5, "D")
check_raids(s6, use_s6 and show_d, s6d_highs, s6d_lows, s6c_h, s6c_l, s6d_rh, s6d_rl, 6, "D")
check_raids(s7, use_s7 and show_d, s7d_highs, s7d_lows, s7c_h, s7c_l, s7d_rh, s7d_rl, 7, "D")
check_raids(s8, use_s8 and show_d, s8d_highs, s8d_lows, s8c_h, s8c_l, s8d_rh, s8d_rl, 8, "D")

// weekly
check_raids(s0, use_s0 and show_w, s0w_highs, s0w_lows, s0c_h, s0c_l, s0w_rh, s0w_rl, 0, "W")
check_raids(s1, use_s1 and show_w, s1w_highs, s1w_lows, s1c_h, s1c_l, s1w_rh, s1w_rl, 1, "W")
check_raids(s2, use_s2 and show_w, s2w_highs, s2w_lows, s2c_h, s2c_l, s2w_rh, s2w_rl, 2, "W")
check_raids(s3, use_s3 and show_w, s3w_highs, s3w_lows, s3c_h, s3c_l, s3w_rh, s3w_rl, 3, "W")
check_raids(s4, use_s4 and show_w, s4w_highs, s4w_lows, s4c_h, s4c_l, s4w_rh, s4w_rl, 4, "W")
check_raids(s5, use_s5 and show_w, s5w_highs, s5w_lows, s5c_h, s5c_l, s5w_rh, s5w_rl, 5, "W")
check_raids(s6, use_s6 and show_w, s6w_highs, s6w_lows, s6c_h, s6c_l, s6w_rh, s6w_rl, 6, "W")
check_raids(s7, use_s7 and show_w, s7w_highs, s7w_lows, s7c_h, s7c_l, s7w_rh, s7w_rl, 7, "W")
check_raids(s8, use_s8 and show_w, s8w_highs, s8w_lows, s8c_h, s8c_l, s8w_rh, s8w_rl, 8, "W")

// monthly
check_raids(s0, use_s0 and show_m, s0m_highs, s0m_lows, s0c_h, s0c_l, s0m_rh, s0m_rl, 0, "M")
check_raids(s1, use_s1 and show_m, s1m_highs, s1m_lows, s1c_h, s1c_l, s1m_rh, s1m_rl, 1, "M")
check_raids(s2, use_s2 and show_m, s2m_highs, s2m_lows, s2c_h, s2c_l, s2m_rh, s2m_rl, 2, "M")
check_raids(s3, use_s3 and show_m, s3m_highs, s3m_lows, s3c_h, s3c_l, s3m_rh, s3m_rl, 3, "M")
check_raids(s4, use_s4 and show_m, s4m_highs, s4m_lows, s4c_h, s4c_l, s4m_rh, s4m_rl, 4, "M")
check_raids(s5, use_s5 and show_m, s5m_highs, s5m_lows, s5c_h, s5c_l, s5m_rh, s5m_rl, 5, "M")
check_raids(s6, use_s6 and show_m, s6m_highs, s6m_lows, s6c_h, s6c_l, s6m_rh, s6m_rl, 6, "M")
check_raids(s7, use_s7 and show_m, s7m_highs, s7m_lows, s7c_h, s7c_l, s7m_rh, s7m_rl, 7, "M")
check_raids(s8, use_s8 and show_m, s8m_highs, s8m_lows, s8c_h, s8c_l, s8m_rh, s8m_rl, 8, "M")
// ------------------------------ Check Raids ------------------------------


// ------------------------------ Current Chart ------------------------------
d_style := get_line_style(d_style)
w_style := get_line_style(w_style)
m_style := get_line_style(m_style)

if show_c
    if show_d
        chart_pivot(s9d_o, s9d_h, s9d_l, s9d_highs, s9d_lows, pdh, pdl, pdh_label, pdl_label, "D", d_style, d_width)
    if show_w
        chart_pivot(s9w_o, s9w_h, s9w_l, s9w_highs, s9w_lows, pwh, pwl, pwh_label, pwl_label, "W", w_style, w_width)
    if show_m
        chart_pivot(s9m_o, s9m_h, s9m_l, s9m_highs, s9m_lows, pmh, pml, pmh_label, pml_label, "M", m_style, m_width)
// ------------------------------ Current Chart ------------------------------


// ------------------------------ Dashboard ------------------------------
var stats = table.new(get_table_position(table_position), 20, 20, tbl_bg, tbl_fr, tbl_fr_w, tbl_bd, tbl_bd_w)
if barstate.islast
    _size = get_size(text_size)
    table.cell(stats, 0, 0, "Symbol", text_size = _size)
    
    if show_d
        table.cell(stats, 1, 0, "PDH", text_size = _size)
        table.cell(stats, 2, 0, "PDL", text_size = _size)

        update_table(stats, 1, 1, use_s0, s0, s0d_h, s0d_l, s0d_c, s0d_highs, s0d_lows)
        update_table(stats, 1, 2, use_s1, s1, s1d_h, s1d_l, s1d_c, s1d_highs, s1d_lows)
        update_table(stats, 1, 3, use_s2, s2, s2d_h, s2d_l, s2d_c, s2d_highs, s2d_lows)
        update_table(stats, 1, 4, use_s3, s3, s3d_h, s3d_l, s3d_c, s3d_highs, s3d_lows)
        update_table(stats, 1, 5, use_s4, s4, s4d_h, s4d_l, s4d_c, s4d_highs, s4d_lows)
        update_table(stats, 1, 6, use_s5, s5, s5d_h, s5d_l, s5d_c, s5d_highs, s5d_lows)
        update_table(stats, 1, 7, use_s6, s6, s6d_h, s6d_l, s6d_c, s6d_highs, s6d_lows)
        update_table(stats, 1, 8, use_s7, s7, s7d_h, s7d_l, s7d_c, s7d_highs, s7d_lows)
        update_table(stats, 1, 9, use_s8, s8, s8d_h, s8d_l, s8d_c, s8d_highs, s8d_lows)
    
    if show_w
        table.cell(stats, 3, 0, "PWH", text_size = _size)
        table.cell(stats, 4, 0, "PWL", text_size = _size)

        update_table(stats, 3, 1, use_s0, s0, s0w_h, s0w_l, s0w_c, s0w_highs, s0w_lows)
        update_table(stats, 3, 2, use_s1, s1, s1w_h, s1w_l, s1w_c, s1w_highs, s1w_lows)
        update_table(stats, 3, 3, use_s2, s2, s2w_h, s2w_l, s2w_c, s2w_highs, s2w_lows)
        update_table(stats, 3, 4, use_s3, s3, s3w_h, s3w_l, s3w_c, s3w_highs, s3w_lows)
        update_table(stats, 3, 5, use_s4, s4, s4w_h, s4w_l, s4w_c, s4w_highs, s4w_lows)
        update_table(stats, 3, 6, use_s5, s5, s5w_h, s5w_l, s5w_c, s5w_highs, s5w_lows)
        update_table(stats, 3, 7, use_s6, s6, s6w_h, s6w_l, s6w_c, s6w_highs, s6w_lows)
        update_table(stats, 3, 8, use_s7, s7, s7w_h, s7w_l, s7w_c, s7w_highs, s7w_lows)
        update_table(stats, 3, 9, use_s8, s8, s8w_h, s8w_l, s8w_c, s8w_highs, s8w_lows)
    
    if show_m
        table.cell(stats, 5, 0, "PMH", text_size = _size)
        table.cell(stats, 6, 0, "PML", text_size = _size)

        update_table(stats, 5, 1, use_s0, s0, s0m_h, s0m_l, s0m_c, s0m_highs, s0m_lows)
        update_table(stats, 5, 2, use_s1, s1, s1m_h, s1m_l, s1m_c, s1m_highs, s1m_lows)
        update_table(stats, 5, 3, use_s2, s2, s2m_h, s2m_l, s2m_c, s2m_highs, s2m_lows)
        update_table(stats, 5, 4, use_s3, s3, s3m_h, s3m_l, s3m_c, s3m_highs, s3m_lows)
        update_table(stats, 5, 5, use_s4, s4, s4m_h, s4m_l, s4m_c, s4m_highs, s4m_lows)
        update_table(stats, 5, 6, use_s5, s5, s5m_h, s5m_l, s5m_c, s5m_highs, s5m_lows)
        update_table(stats, 5, 7, use_s6, s6, s6m_h, s6m_l, s6m_c, s6m_highs, s6m_lows)
        update_table(stats, 5, 8, use_s7, s7, s7m_h, s7m_l, s7m_c, s7m_highs, s7m_lows)
        update_table(stats, 5, 9, use_s8, s8, s8m_h, s8m_l, s8m_c, s8m_highs, s8m_lows)
// ------------------------------ Dashboard ------------------------------



