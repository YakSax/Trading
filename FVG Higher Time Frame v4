

//@version=5
indicator("FVG Higher Time Frame v4", "LuxAlgo's FVG HTF v4", overlay = true, max_lines_count = 500, max_boxes_count = 500)

//------------------------------------------------------------------------------
//Settings
//-----------------------------------------------------------------------------{
thresholdPer = input.float(0.04, "Threshold %", minval = 0, maxval = 100, step = .01, inline = 'threshold', group = 'FVG Settings')
auto = input(false, "Auto", inline = 'threshold', group = 'FVG Settings')
maxKeep_FVGs = input.int(5, "Max FVGs to Display", minval=1, tooltip="Only the N most‐recent FVGs will remain on the chart & in memory", group = 'FVG Settings')
showLast_FVGs = input.int(0, 'Unmitigated FVG Levels', minval = 0, group = 'FVG Settings')
mitigationLevels = input.bool(false, 'Mitigation Levels for FVGs', group = 'FVG Settings')
tf_input_1 = input.timeframe('15', "FVG Timeframe 1", group = 'FVG Settings')
tf_input_2 = input.timeframe('60', "FVG Timeframe 2", group = 'FVG Settings')

//Style
extend = input.int(20, 'Extend', minval = 0, inline = 'extend', group = 'FVG Settings')
dynamic = input(false, 'Dynamic', inline = 'extend', group = 'FVG Settings')
bullCss = input.color(color.new(#088f99, 70), "Bullish FVG", group = 'FVG Settings')
bearCss = input.color(color.new(#f23675, 70), "Bearish FVG", group = 'FVG Settings')
border_color_input = input.color(color.rgb(185, 191, 217, 40), title = "Box Border Color", group = "FVG Settings")

// New Label Settings
FVG_label_color    = input.color(color.rgb(186, 188, 196, 50), title = "Box Labels", group = "FVG Settings")
box_label_size_input = input.string('Small', title = 'Box Label Size', options = ['Tiny', 'Small', 'Normal'], group ="FVG Settings")
invis = color.new(#9b9c9b, 90)

// Function to convert user selection into size
GetBoxLabelSize(BoxLabelSize) =>
    BoxLabelSize == 'Tiny'  ? size.tiny  : BoxLabelSize == 'Small' ? size.small :BoxLabelSize == 'Normal'? size.normal: size.small  // Default
// Convert size settings string into actual size
BoxLabelSize = GetBoxLabelSize(box_label_size_input)
//-----------------------------------------------------------------------------}
//UDT's
//-----------------------------------------------------------------------------{
type fvg
    float max
    float min
    bool  isbull
    int   t = time

var string _fvgLabel = "FVG"
var string _plus     = "+"
var string _minus    = "-"
var string _empty    = ""

//-----------------------------------------------------------------------------}
//Methods/Functions
//-----------------------------------------------------------------------------{

// Function to format timeframe into string
format_tf(tf_input) =>
    // Minutes handling (1–59)
    isMinutes = str.tonumber(tf_input) and str.tonumber(tf_input) < 60
    // Hours handling (60, 120, 180, 240)
    isHours = str.tonumber(tf_input) and str.tonumber(tf_input) % 60 == 0 and str.tonumber(tf_input) <= 240
    
    tf_result = 
         isMinutes ? str.tostring(str.tonumber(tf_input)) + "min" :
         isHours   ? str.tostring(str.tonumber(tf_input) / 60) + "H" :
         tf_input  // leave day/week/month etc. as-is
    tf_result

method tosolid(color id)=> color.rgb(color.r(id),color.g(id),color.b(id))

detect()=>
    var new_fvg = fvg.new(na, na, na, na)
    threshold = auto ? ta.cum((high - low) / low) / bar_index : thresholdPer / 100

    bull_fvg = low > high[2] and close[1] > high[2] and (low - high[2]) / high[2] > threshold
    bear_fvg = high < low[2] and close[1] < low[2] and (low[2] - high) / high > threshold
    
    if bull_fvg
        new_fvg := fvg.new(low, high[2], true)
    else if bear_fvg
        new_fvg := fvg.new(low[2], high, false)

    [bull_fvg, bear_fvg, new_fvg]

// TF-string -> minutes helper (used in extension math)
f_tf_in_minutes(tf_str) =>
    S = str.upper(tf_str)
    nOnly = str.tonumber(S)
    if not na(nOnly)
        nOnly
    else
        last = str.substring(S, str.length(S) - 1, str.length(S))
        n    = str.tonumber(str.substring(S, 0, str.length(S) - 1))
        last == "S" ? n / 60 :
         last == "H" ? n * 60 :
         last == "D" ? n * 1440 :
         last == "W" ? n * 10080 :
         last == "M" ? n * 43200 : na    // months ≈ 30 days

// Generalized create_fvg_box that uses a passed-in TF string (so labels & scaling are correct)
create_fvg_box(new_fvg, isBull, tf_input_param) =>
    var box b = na

    // minutes for the FVG TF and chart TF
    tf_minutes       = f_tf_in_minutes(tf_input_param)
    chart_tf_minutes = f_tf_in_minutes(timeframe.period)
    tfString = format_tf(tf_input_param)
    // choose what "extend" means. Here extend is in chart bars; original author used extend * chart_tf_minutes
    extend_minutes = extend * chart_tf_minutes

    // convert minutes -> milliseconds and force INT
    // Keep the same scaling approach you used previously (preserving your intent)
    // prevent divide-by-zero by adding a small epsilon when necessary
    ratio_guard = (chart_tf_minutes / (tf_minutes == 0 ? 1 : tf_minutes)) + 0.001
    // delta_ms calculation: scaled by ratio_guard (keeps relative scaling similar to your previous approach)
    delta_ms = int(math.round(extend_minutes * 60000) / ratio_guard)
    left_ts  = int(new_fvg.t)                   // ensure int
    right_ts = left_ts + delta_ms + 1           // now int (ms)

    b := box.new(left_ts, new_fvg.max, right_ts, new_fvg.min,
                 xloc = xloc.bar_time,
                 border_color = border_color_input,
                 bgcolor = isBull ? bullCss : bearCss,
                 text = (tfString + _empty + _fvgLabel + (isBull ? _plus : _minus)),
                 text_halign = text.align_right, text_valign = text.align_bottom,
                 text_size = BoxLabelSize, text_color = FVG_label_color)

    b

//-----------------------------------------------------------------------------}
//FVG's detection/display for TF1 and TF2
//-----------------------------------------------------------------------------{
// Create per-TF data structures so they don't collide
var fvg_records_1 = array.new<fvg>(0)
var fvg_areas_1   = array.new<box>(0)
var t1 = 0
var float max_bull_fvg_1 = na, var float min_bull_fvg_1 = na, var bull_count_1 = 0, var bull_mitigated_1 = 0
var float max_bear_fvg_1 = na, var float min_bear_fvg_1 = na, var bear_count_1 = 0, var bear_mitigated_1 = 0

var fvg_records_2 = array.new<fvg>(0)
var fvg_areas_2   = array.new<box>(0)
var t2 = 0
var float max_bull_fvg_2 = na, var float min_bull_fvg_2 = na, var bull_count_2 = 0, var bull_mitigated_2 = 0
var float max_bear_fvg_2 = na, var float min_bear_fvg_2 = na, var bear_count_2 = 0, var bear_mitigated_2 = 0

// Call detect() on both user timeframes
[bull_fvg_1, bear_fvg_1, new_fvg_1] = request.security(syminfo.tickerid, tf_input_1, detect())
[bull_fvg_2, bear_fvg_2, new_fvg_2] = request.security(syminfo.tickerid, tf_input_2, detect())

// --- Handle TF1 FVGs ---
if bull_fvg_1 and new_fvg_1.t != t1
    if dynamic
        max_bull_fvg_1 := new_fvg_1.max
        min_bull_fvg_1 := new_fvg_1.min
    
    //Populate FVG array & create box
    if not dynamic
        b1 = create_fvg_box(new_fvg_1, true, tf_input_1)
        fvg_areas_1.unshift(b1)
    fvg_records_1.unshift(new_fvg_1)
 
    if fvg_records_1.size() > maxKeep_FVGs
        idx = fvg_records_1.size() - 1
        fvg_records_1.remove(idx)
        if not dynamic
            oldBox = fvg_areas_1.remove(idx)
            oldBox.delete()

    bull_count_1 += 1
    t1 := new_fvg_1.t
else if dynamic
    max_bull_fvg_1 := math.max(math.min(close, max_bull_fvg_1), min_bull_fvg_1)

//Bear TF1
if bear_fvg_1 and new_fvg_1.t != t1
    if dynamic
        max_bear_fvg_1 := new_fvg_1.max
        min_bear_fvg_1 := new_fvg_1.min

    if not dynamic
        b1 = create_fvg_box(new_fvg_1, false, tf_input_1)
        fvg_areas_1.unshift(b1)
    fvg_records_1.unshift(new_fvg_1)

    if fvg_records_1.size() > maxKeep_FVGs
        idx = fvg_records_1.size() - 1
        fvg_records_1.remove(idx)
        if not dynamic
            oldBox = fvg_areas_1.remove(idx)
            oldBox.delete()

    bear_count_1 += 1
    t1 := new_fvg_1.t
else if dynamic
    min_bear_fvg_1 := math.min(math.max(close, min_bear_fvg_1), max_bear_fvg_1) 


// --- Handle TF2 FVGs ---
if bull_fvg_2 and new_fvg_2.t != t2
    if dynamic
        max_bull_fvg_2 := new_fvg_2.max
        min_bull_fvg_2 := new_fvg_2.min
    
    if not dynamic
        b2 = create_fvg_box(new_fvg_2, true, tf_input_2)
        fvg_areas_2.unshift(b2)
    fvg_records_2.unshift(new_fvg_2)
 
    if fvg_records_2.size() > maxKeep_FVGs
        idx = fvg_records_2.size() - 1
        fvg_records_2.remove(idx)
        if not dynamic
            oldBox = fvg_areas_2.remove(idx)
            oldBox.delete()

    bull_count_2 += 1
    t2 := new_fvg_2.t
else if dynamic
    max_bull_fvg_2 := math.max(math.min(close, max_bull_fvg_2), min_bull_fvg_2)

//Bear TF2
if bear_fvg_2 and new_fvg_2.t != t2
    if dynamic
        max_bear_fvg_2 := new_fvg_2.max
        min_bear_fvg_2 := new_fvg_2.min

    if not dynamic
        b2 = create_fvg_box(new_fvg_2, false, tf_input_2)
        fvg_areas_2.unshift(b2)
    fvg_records_2.unshift(new_fvg_2)

    if fvg_records_2.size() > maxKeep_FVGs
        idx = fvg_records_2.size() - 1
        fvg_records_2.remove(idx)
        if not dynamic
            oldBox = fvg_areas_2.remove(idx)
            oldBox.delete()

    bear_count_2 += 1
    t2 := new_fvg_2.t
else if dynamic
    min_bear_fvg_2 := math.min(math.max(close, min_bear_fvg_2), max_bear_fvg_2) 

//-----------------------------------------------------------------------------}
//Unmitigated/Mitigated lines (separate per TF)
//-----------------------------------------------------------------------------{
// TF1 mitigation
if fvg_records_1.size() > 0
    for i = fvg_records_1.size()-1 to 0
        get = fvg_records_1.get(i)

        if get.isbull
            if close < get.min
                if mitigationLevels
                    line.new(get.t
                      , get.min
                      , time
                      , get.min
                      , xloc.bar_time
                      , color = bullCss
                      , style = line.style_dashed)

                if not dynamic
                    area = fvg_areas_1.remove(i)
                    area.delete()

                fvg_records_1.remove(i)
                bull_mitigated_1 += 1
        else if close > get.max
            if mitigationLevels
                line.new(get.t
                  , get.max
                  , time
                  , get.max
                  , xloc.bar_time
                  , color = bearCss
                  , style = line.style_dashed)

            if not dynamic
                area = fvg_areas_1.remove(i)
                area.delete()
            
            fvg_records_1.remove(i)
            bear_mitigated_1 += 1

// TF2 mitigation
if fvg_records_2.size() > 0
    for i = fvg_records_2.size()-1 to 0
        get = fvg_records_2.get(i)

        if get.isbull
            if close < get.min
                if mitigationLevels
                    line.new(get.t
                      , get.min
                      , time
                      , get.min
                      , xloc.bar_time
                      , color = bullCss
                      , style = line.style_dashed)

                if not dynamic
                    area = fvg_areas_2.remove(i)
                    area.delete()

                fvg_records_2.remove(i)
                bull_mitigated_2 += 1
        else if close > get.max
            if mitigationLevels
                line.new(get.t
                  , get.max
                  , time
                  , get.max
                  , xloc.bar_time
                  , color = bearCss
                  , style = line.style_dashed)

            if not dynamic
                area = fvg_areas_2.remove(i)
                area.delete()
            
            fvg_records_2.remove(i)
            bear_mitigated_2 += 1

//Unmitigated lines (both TFs)
var unmitigated_1 = array.new<line>(0)
var unmitigated_2 = array.new<line>(0)

// TF1 unmitigated lines shown at last bar
if barstate.islast and showLast_FVGs > 0 and fvg_records_1.size() > 0
    if unmitigated_1.size() > 0 
        for element in unmitigated_1
            element.delete()
        unmitigated_1.clear()

    for i = 0 to math.min(showLast_FVGs-1, fvg_records_1.size()-1)
        get = fvg_records_1.get(i)

        unmitigated_1.push(line.new(get.t
          , get.isbull ? get.min : get.max 
          , time
          , get.isbull ? get.min : get.max
          , xloc.bar_time
          , color = get.isbull ? bullCss : bearCss))

// TF2 unmitigated lines shown at last bar
if barstate.islast and showLast_FVGs > 0 and fvg_records_2.size() > 0
    if unmitigated_2.size() > 0 
        for element in unmitigated_2
            element.delete()
        unmitigated_2.clear()

    for i = 0 to math.min(showLast_FVGs-1, fvg_records_2.size()-1)
        get = fvg_records_2.get(i)

        unmitigated_2.push(line.new(get.t
          , get.isbull ? get.min : get.max 
          , time
          , get.isbull ? get.min : get.max
          , xloc.bar_time
          , color = get.isbull ? bullCss : bearCss))

//-----------------------------------------------------------------------------}
//Plots
//-----------------------------------------------------------------------------{
//Dynamic Bull FVG (combined plots kept na so fill still works if dynamic is used)
max_bull_plot = plot(max_bull_fvg_1, color = na)
min_bull_plot = plot(min_bull_fvg_1, color = na)
fill(max_bull_plot, min_bull_plot, color = bullCss)

//Dynamic Bear FVG
max_bear_plot = plot(max_bear_fvg_1, color = na)
min_bear_plot = plot(min_bear_fvg_1, color = na)
fill(max_bear_plot, min_bear_plot, color = bearCss)

//-----------------------------------------------------------------------------}
//Alerts (combined counts across TFs for convenience)
alertcondition(bull_count_1 + bull_count_2 > (bull_count_1 + bull_count_2)[1], 'Bullish FVG', 'Bullish FVG detected')
alertcondition(bear_count_1 + bear_count_2 > (bear_count_1 + bear_count_2)[1], 'Bearish FVG', 'Bearish FVG detected')

alertcondition(bull_mitigated_1 + bull_mitigated_2 > (bull_mitigated_1 + bull_mitigated_2)[1], 'Bullish FVG Mitigation', 'Bullish FVG mitigated')
alertcondition(bear_mitigated_1 + bear_mitigated_2 > (bear_mitigated_1 + bear_mitigated_2)[1], 'Bearish FVG Mitigation', 'Bearish FVG mitigated')

//-----------------------------------------------------------------------------}


